{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"parent":"fa0bf5fe3ed8","children":[],"id":"c26bbd50be5b","title":"健康工作、开心生活"},{"parent":"fa0bf5fe3ed8","children":[],"id":"e76ff4cd83b4","title":"工作中多和领导沟通，让对方知道你现在的困难点，疑惑点这样有利于自己的快速成长&nbsp; 项目遇到阻力也要第一时间表达出来，按时完成是你和领导共同的kpi 你延期了他可能比你还难受，而他不会丢饭碗，你会"},{"parent":"fa0bf5fe3ed8","children":[],"id":"16bc5379015e","title":"确保当前做的事情是有意义的，能给自己不断带来成长的，职场前几年不要太看重钱，能力上去钱很容易就来了"},{"parent":"fa0bf5fe3ed8","children":[],"id":"caae56e73bc1","title":"跳出当前所做事情的局限，带着leader的思维去干好你每一年的工作你才有可能加速让自己成为leader"},{"parent":"fa0bf5fe3ed8","children":[],"id":"74e0474739a2","title":"定期给自己定一些小目标，确保目标是正确的，然后拆分目标一件件落实"},{"parent":"fa0bf5fe3ed8","children":[],"id":"15121f5b1149","title":"埋头苦干之前，先抬头看路"}],"collapsed":false,"id":"fa0bf5fe3ed8","title":"职场最重要的几件事","summaries":[{"summary":true,"parent":"fa0bf5fe3ed8","children":[],"range":"0,5","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"bca9acab13d7","title":"健康开心会加速你的成长"}]},{"parent":"root","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"7bf23aa1cda3","children":[],"id":"4f55a8f7bc71","title":"不要碰自己不懂的行业，只知道皮毛不算懂，最好自己从事什么行业，就投资这个行业的头部公司"},{"parent":"7bf23aa1cda3","children":[],"id":"5435c00220f1","title":"如果只是投一点点钱玩玩，没必要天天看涨跌或喜或忧的，放那不动，好好工作，最后你会发现还是工作来钱快"},{"parent":"7bf23aa1cda3","children":[],"id":"ef2028e960e1","title":"因为无知，所以大家不敢重点投资一两家公司，买几个十几个股票的大有人在，因为你还不够了解，如果你足够了解市场和公司的时候就应该只投几家你足够有把我的公司然后等风来。"},{"parent":"7bf23aa1cda3","children":[],"id":"d23af72634bd","title":"人生只需要把握一到两次重大的投资 all in进去即可翻身了，几万几千的小打小闹不会改变你的生活，如果没这个认知之前，不如好好工作赚钱买房来的实在，浅显的投资会分散你的精力"},{"parent":"7bf23aa1cda3","children":[],"id":"38898f0a49cb","title":"投资本身涉及的点不应该局限于眼前，而是未来，行业的未来，公司在这个行业所处的地位，未来几年是否有重大突破，管理层价值观你是否认可等等一系列因素，不要因为你觉得好就买了，这根赌没啥区别"}],"collapsed":false,"id":"7bf23aa1cda3","title":"投资最重要的事情","summaries":[{"summary":true,"parent":"7bf23aa1cda3","children":[],"range":"0,4","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"fcda56acae88","title":"人生把握一到两次重大投资就够了，天天盯着支付宝欢喜交加啥也捞不到"}]},{"parent":"root","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"6f007389482a","children":[],"id":"0f5e0b974553","title":"我的学习方法比较简单，北极星目标，给自己定下目标之后，不断拆分 每次完成小目标就离大目标进一步"},{"parent":"6f007389482a","children":[{"parent":"eb7fa1390795","children":[],"id":"a6a383887a02","title":"我之前是大数据团队的我们会和算法有很多合作，我知道算法推荐不断完善模型背后的目的，就是杀死用户的时间"}],"id":"eb7fa1390795","title":"卸载掉哪些信息流软件，他们杀你时间的方式太简单粗暴了"},{"parent":"6f007389482a","children":[],"id":"a2bfe742e609","title":"我看书学习的时候会把手机丢很远，其实也不会有什么重要的人和事情找你，不要一直看，真的着急他们会打电话的。"},{"parent":"6f007389482a","children":[],"id":"b018af1367cb","title":"坚持"}],"collapsed":false,"id":"6f007389482a","title":"学习方法"},{"parent":"root","lineStyle":{"randomLineColor":"#FCB52A"},"children":[{"parent":"837c96a6385b","children":[{"parent":"2066010f888a","children":[{"parent":"e648fa05e857","children":[],"id":"79b12192ae79","title":"数组+链表"},{"parent":"e648fa05e857","children":[],"id":"a91d2eb87aba","title":"头插"}],"id":"e648fa05e857","title":"1.7"},{"parent":"2066010f888a","children":[{"parent":"2a97208ebd55","children":[],"id":"5ef1196c6c22","title":"数组+链表+红黑树"},{"parent":"2a97208ebd55","children":[],"id":"64a36541f70f","title":"尾插"}],"id":"2a97208ebd55","title":"1.8"},{"parent":"2066010f888a","children":[{"parent":"c541f9c825c9","children":[],"id":"dea4bbe7ecf3","title":"LoadFactory 默认0.75"},{"parent":"c541f9c825c9","children":[{"parent":"aac99e76c818","children":[],"id":"090ffcb3f316","title":"Hash公式跟长度有关"}],"id":"aac99e76c818","title":"创建一个空数组重新Hash"}],"id":"c541f9c825c9","title":"扩容机制"},{"parent":"2066010f888a","children":[{"parent":"22efc43ddd1b","children":[],"id":"e0a3b700c39f","title":"子主题"}],"id":"22efc43ddd1b","title":"线程不安全"},{"parent":"2066010f888a","children":[{"parent":"ef1b1af32800","children":[],"id":"1c636bf34514","title":"方便位运算"},{"parent":"ef1b1af32800","children":[],"id":"df06138de803","title":"均匀分布"}],"id":"ef1b1af32800","title":"2的幂次"},{"parent":"2066010f888a","children":[],"id":"051a6fc8492e","title":"重写equals必须重写HashCode"}],"id":"2066010f888a","title":"HashMap"},{"parent":"837c96a6385b","children":[{"parent":"5e1f312e059b","children":[],"id":"96586e5183de","title":"安全失败"},{"parent":"5e1f312e059b","children":[{"parent":"f0cc32ef0028","children":[],"id":"29ef6d58423b","title":"数组+链表"},{"parent":"f0cc32ef0028","children":[{"parent":"a284a6ef3360","children":[{"parent":"7a44e05a00a2","children":[],"id":"9557963578c4","title":"子主题"}],"id":"7a44e05a00a2","title":"继承了reentranLock"},{"parent":"a284a6ef3360","children":[],"id":"20de04efc181","title":"尝试获取锁存在并发竞争&nbsp; 自旋&nbsp; 阻塞"}],"id":"a284a6ef3360","title":"segment分段锁"},{"parent":"f0cc32ef0028","children":[],"id":"39a777f368e5","title":"get高效 volatile修饰 不需要加锁"},{"parent":"f0cc32ef0028","children":[],"id":"9416a7dcedeb","title":"volatile修饰节点指针"},{"parent":"f0cc32ef0028","children":[],"id":"f6aff036b512","title":"HashEntry"}],"id":"f0cc32ef0028","title":"1.7"},{"parent":"5e1f312e059b","children":[{"parent":"d1d752405db8","children":[],"id":"b8c124c9745c","title":"数组+链表+红黑树"},{"parent":"d1d752405db8","children":[{"parent":"16f1d9df4a36","children":[{"parent":"ac34adea5406","children":[],"id":"fa92ad6c5847","title":"再失败就sync保证"}],"id":"ac34adea5406","title":"cas失败自旋保证成功"}],"id":"16f1d9df4a36","title":"CAS+synchronized"},{"parent":"d1d752405db8","children":[],"id":"6f5f2322a40a","title":"node"}],"id":"d1d752405db8","title":"1.8"}],"id":"5e1f312e059b","title":"ConcurrentHashMap"},{"parent":"837c96a6385b","children":[{"parent":"8de31258cc9b","children":[],"id":"82ce8c0e6982","title":"数组"},{"parent":"8de31258cc9b","children":[],"id":"039d8616aa38","title":"查找 访问速度快&nbsp; 增删效率低 线程不安全"}],"id":"8de31258cc9b","title":"ArrayList"},{"parent":"837c96a6385b","children":[{"parent":"dfe0db5df668","children":[],"id":"a12a5e826f2f","title":"双向链表"},{"parent":"dfe0db5df668","children":[],"id":"40e45ccb00d1","title":"适合插入删除频繁的情况&nbsp; 内部维护了链表的长度"}],"id":"dfe0db5df668","title":"LinkedList"}],"collapsed":false,"id":"837c96a6385b","title":"集合"},{"parent":"root","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"parent":"d6cae9aebc48","children":[{"parent":"b189096e1418","children":[],"id":"ae12719eabe7","title":"语音"},{"parent":"b189096e1418","children":[],"id":"30fda7ba3bbc","title":"视频"},{"parent":"b189096e1418","children":[],"id":"6b8dba47cf0c","title":"直播"}],"id":"b189096e1418","title":"UDP"},{"parent":"d6cae9aebc48","children":[{"parent":"8243c1d75821","children":[{"parent":"83dd8517cdeb","children":[],"id":"c67337378349","title":"syn seq"},{"parent":"83dd8517cdeb","children":[],"id":"b454ee16d96b","title":"syn ack seq"},{"parent":"83dd8517cdeb","children":[],"id":"0d71ffd90ae9","title":"ack seq"},{"parent":"83dd8517cdeb","children":[],"id":"a9f9212c2e76","title":"为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。"}],"id":"83dd8517cdeb","title":"三次握手"},{"parent":"8243c1d75821","children":[{"parent":"c0c7d0da9051","children":[],"id":"02cf32183939","title":"fin ack seq"},{"parent":"c0c7d0da9051","children":[],"id":"4bf430662764","title":"ack seq<br>fin ack seq"},{"parent":"c0c7d0da9051","children":[],"id":"84be957d3e61","title":"ack seq"}],"id":"c0c7d0da9051","title":"四次挥手"},{"parent":"8243c1d75821","children":[{"parent":"7d3debd4f8e2","children":[],"id":"d9f9d4713423","title":"网络会话"},{"parent":"7d3debd4f8e2","children":[],"id":"baef8e1af1fc","title":"文件传输"},{"parent":"7d3debd4f8e2","children":[],"id":"08775c22f513","title":"发送接收邮件"},{"parent":"7d3debd4f8e2","children":[],"id":"9cd0a8e00fe2","title":"远程登录"}],"id":"7d3debd4f8e2","title":"场景"},{"parent":"8243c1d75821","children":[],"id":"90a3c6442df4","title":"如何保证可靠"}],"id":"8243c1d75821","title":"TCP"},{"parent":"d6cae9aebc48","children":[],"id":"66c2919b78da","title":"HTTP"},{"parent":"d6cae9aebc48","children":[{"parent":"b01798e52301","children":[],"id":"98cb772918d9","title":"为啥安全"}],"id":"b01798e52301","title":"HTTPS"},{"parent":"d6cae9aebc48","children":[{"parent":"953384062da0","children":[],"id":"96136d0687f4","title":"阻塞等待链接"},{"parent":"953384062da0","children":[],"id":"b18f0a0ef487","title":"阻塞等待数据"},{"parent":"953384062da0","children":[],"id":"bf60de6a7b35","title":"开线程处理并发"},{"parent":"953384062da0","children":[],"id":"e2496ca03025","title":"耗资源"}],"id":"953384062da0","title":"BIO"},{"parent":"d6cae9aebc48","children":[{"parent":"7c362075aabf","children":[],"id":"e3a88a774e68","title":"非阻塞IO"},{"parent":"7c362075aabf","children":[],"id":"5a2daf3c4d61","title":"epoll"}],"id":"7c362075aabf","title":"NIO"},{"parent":"d6cae9aebc48","children":[{"parent":"135bddf140d4","children":[],"id":"f08966e3950e","title":"在报文末尾增加换行符表明一条完整的消息，这样在接收端可以根据这个换行符来判断消息是否完整。<br>将消息分为消息头、消息体。可以在消息头中声明消息的长度，根据这个长度来获取报文（比如 808 协议）。<br>规定好报文长度，不足的空位补齐，取的时候按照长度截取即可。"}],"id":"135bddf140d4","title":"粘包/拆包"},{"parent":"d6cae9aebc48","children":[{"parent":"198b74e5486e","children":[{"parent":"3cde45bd1477","children":[],"id":"533c1851e624","title":"单个进程可监视的fd数量被限制，即能监听端口的大小有限。"},{"parent":"3cde45bd1477","children":[],"id":"cd51ccf7770c","title":"对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低："},{"parent":"3cde45bd1477","children":[],"id":"0320c58f960b","title":"需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大"}],"id":"3cde45bd1477","title":"select"},{"parent":"198b74e5486e","children":[{"parent":"079455ff065a","children":[],"id":"d1b554028732","title":"大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义"},{"parent":"079455ff065a","children":[],"id":"65fc05a647c2","title":"poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。"}],"id":"079455ff065a","title":"poll"},{"parent":"198b74e5486e","children":[{"parent":"bf6bbd8ad20f","children":[],"id":"6bd1882400bc","title":"没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；"},{"parent":"bf6bbd8ad20f","children":[],"id":"96a34734b018","title":"效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。"},{"parent":"bf6bbd8ad20f","children":[],"id":"ed7a43174bf2","title":"内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。"}],"id":"bf6bbd8ad20f","title":"epoll"}],"id":"198b74e5486e","title":"多路复用"},{"parent":"d6cae9aebc48","children":[],"id":"a6748616a167","title":"neetty 非异步&nbsp; 阻塞&nbsp; response&nbsp; trse id&nbsp; 感觉<br>"},{"parent":"d6cae9aebc48","children":[],"id":"5b229c06ebba","title":"序列化"}],"collapsed":false,"id":"d6cae9aebc48","title":"基础"},{"parent":"root","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"parent":"c28281419b7b","children":[{"parent":"6980922825c2","children":[{"parent":"b4f977bb4ee1","children":[{"parent":"8a359b4e6dd7","children":[],"id":"d043531e0816","title":"Mark Word（存储对象的HashCode，分代年龄和锁标志位信息。）"},{"parent":"8a359b4e6dd7","children":[],"collapsed":false,"id":"4b49018147cf","title":"Klass Point（对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。）"},{"parent":"8a359b4e6dd7","children":[{"parent":"fcd16e9b4c0e","children":[],"id":"7dc151fbdd76","title":"EntryList"},{"parent":"fcd16e9b4c0e","children":[],"id":"2cab8541e7d4","title":"Owner（会指向持有 Monitor 对象的线程）"},{"parent":"fcd16e9b4c0e","children":[],"id":"83fb722bf210","title":"WaitSet"}],"id":"fcd16e9b4c0e","title":"Monitor"}],"id":"8a359b4e6dd7","title":"对象头（Header）"},{"parent":"b4f977bb4ee1","children":[],"id":"992e21525af3","title":"实例数据"},{"parent":"b4f977bb4ee1","children":[],"id":"d52b2c1c79c6","title":"对其填充"}],"id":"b4f977bb4ee1","title":"对象"},{"parent":"6980922825c2","children":[{"parent":"cdfa2c120b54","children":[],"id":"80fa3799ebb6","title":"ACC_SYNCHRONIZED"}],"id":"cdfa2c120b54","title":"方法"},{"parent":"6980922825c2","children":[{"parent":"887500eb5231","children":[],"id":"3de57a53f82c","title":"monitorenter"},{"parent":"887500eb5231","children":[],"id":"250f585ff4bc","title":"monitorexit"},{"parent":"887500eb5231","children":[{"parent":"86baa78b4da8","children":[],"id":"a3b877f38aa5","title":"加减"}],"id":"86baa78b4da8","title":"程序计数器 count"}],"id":"887500eb5231","title":"代码块"},{"parent":"6980922825c2","children":[{"parent":"8052731ecbf5","children":[],"id":"bd2f4913d0e9","title":"无锁"},{"parent":"8052731ecbf5","children":[{"parent":"33585db7ff1b","children":[],"id":"3493ade461af","title":"mark Word 中有线程信息 cas 比较"}],"id":"33585db7ff1b","title":"偏向锁"},{"parent":"8052731ecbf5","children":[{"parent":"499b36c85790","children":[],"id":"35457fd20dff","title":"复制了一份mark work 叫 Lock record 也是cas尝试改变指针"}],"id":"499b36c85790","title":"轻量级"},{"parent":"8052731ecbf5","children":[{"parent":"0c312a8447c5","children":[],"id":"5406f407786d","title":"死循环"}],"id":"0c312a8447c5","title":"自旋"},{"parent":"8052731ecbf5","children":[],"id":"542e68334fe2","title":"重量级"}],"id":"8052731ecbf5","title":"锁膨胀"},{"parent":"6980922825c2","children":[{"parent":"a3a9b0c21049","children":[{"parent":"9bf2d2ef3446","children":[],"id":"10a40ac66834","title":"as-if-serial"},{"parent":"9bf2d2ef3446","children":[],"id":"6665ad887a12","title":"happens-before"}],"id":"9bf2d2ef3446","title":"有序性"},{"parent":"a3a9b0c21049","children":[{"parent":"2547e1a5d36a","children":[],"id":"2407e3e00248","title":"内存强制刷新"}],"id":"2547e1a5d36a","title":"可见性"},{"parent":"a3a9b0c21049","children":[{"parent":"5eca8e436946","children":[],"id":"1922ffd1029b","title":"单一线程持有"}],"id":"5eca8e436946","title":"原子性"},{"parent":"a3a9b0c21049","children":[{"parent":"0948374379dc","children":[],"id":"0d52501728b7","title":"计数器"}],"id":"0948374379dc","title":"可重入性"}],"id":"a3a9b0c21049","title":"特性保证"},{"parent":"6980922825c2","children":[{"parent":"667eca09e0aa","children":[],"id":"772e2fd721c5","title":"用户态内核态切换"}],"id":"667eca09e0aa","title":"重锁"},{"parent":"6980922825c2","children":[{"parent":"47440e618ade","children":[],"id":"1f9b8c25ca30","title":"synchronized是关键字，是JVM层面的底层啥都帮我们做了，而Lock是一个接口，是JDK层面的有丰富的API。<br>synchronized会自动释放锁，而Lock必须手动释放锁。<br>synchronized是不可中断的，Lock可以中断也可以不中断。<br>通过Lock可以知道线程有没有拿到锁，而synchronized不能。<br>synchronized能锁住方法和代码块，而Lock只能锁住代码块。<br>Lock可以使用读锁提高多线程读效率。<br>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。"},{"parent":"47440e618ade","children":[{"parent":"b07b0925c2b0","children":[],"id":"a9f0e250e681","title":"锁升级不可逆"}],"id":"b07b0925c2b0","title":"劣势&nbsp;"}],"id":"47440e618ade","title":"sync 和 Lock的区别"}],"collapsed":false,"id":"6980922825c2","title":"synchronized"},{"parent":"c28281419b7b","children":[{"parent":"07497a89696e","children":[],"id":"73e8a85499ff","title":"内存泄露"},{"parent":"07497a89696e","children":[],"id":"e2f9a7c04cdd","title":"session"}],"id":"07497a89696e","title":"ThreadLocal"},{"parent":"c28281419b7b","children":[{"parent":"e6d0d1f4b6a2","children":[{"parent":"863bfc761499","children":[],"id":"4166f9485229","title":"ReadLock"},{"parent":"863bfc761499","children":[],"id":"db13e254ec49","title":"WriteLock"}],"id":"863bfc761499","title":"ReentrantReadWriteLock"},{"parent":"e6d0d1f4b6a2","children":[{"parent":"27646903999f","children":[{"parent":"a5591c013fad","children":[],"id":"83ce4c80ddb0","title":"tryAcquire"},{"parent":"a5591c013fad","children":[],"id":"74e03f87fba9","title":"acquireQueued"},{"parent":"a5591c013fad","children":[],"id":"8293ab33d574","title":"CAS"}],"id":"a5591c013fad","title":"NonfairSync"},{"parent":"27646903999f","children":[{"parent":"0738f137663d","children":[],"id":"12195bb3a35f","title":"hasQueuedPredecessors"},{"parent":"0738f137663d","children":[],"id":"3dd4c51d3ed3","title":"如果是当前持有锁的线程 可重入"}],"id":"0738f137663d","title":"FairSync"},{"parent":"27646903999f","children":[{"parent":"b281fae99ff2","children":[],"id":"bb36e007e40f","title":"入队 出队"},{"parent":"b281fae99ff2","children":[],"id":"975e544ae6fa","title":"头结点设计"},{"parent":"b281fae99ff2","children":[],"id":"ce35b98da898","title":"共享和独享的实现"},{"parent":"b281fae99ff2","children":[{"parent":"36e5d171736a","children":[],"id":"68e3e0f53e24","title":"实际应用"},{"parent":"36e5d171736a","children":[{"parent":"2f002b3d2744","children":[],"id":"4c28b133412b","title":"cpu开销"},{"parent":"2f002b3d2744","children":[{"parent":"e417f7e9cf71","children":[],"id":"abe6e8e26c2c","title":"AtomicReference"}],"id":"e417f7e9cf71","title":"只能保证一个共享变量原子操作"},{"parent":"2f002b3d2744","children":[{"parent":"5e93255e7cda","children":[],"id":"52707f895b14","title":"标志位&nbsp; 时间戳"}],"id":"5e93255e7cda","title":"ABA"}],"id":"2f002b3d2744","title":"存在的问题"}],"id":"36e5d171736a","title":"CAS"}],"id":"b281fae99ff2","title":"AbstractQueuedSynchronizer"}],"id":"27646903999f","title":"ReentrantLock"},{"parent":"e6d0d1f4b6a2","children":[],"id":"39bb365b4793","title":"StampedLock"}],"id":"e6d0d1f4b6a2","title":"Lock"},{"parent":"c28281419b7b","children":[{"parent":"5b8ac720af41","children":[{"parent":"3e62670c5d38","children":[],"id":"c2977187a49f","title":"当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取"},{"parent":"3e62670c5d38","children":[],"id":"e9f5ab78079c","title":"锁bus"},{"parent":"3e62670c5d38","children":[{"parent":"6741aa18a25f","children":[],"id":"e1dbe2b93181","title":"总线风暴"}],"id":"6741aa18a25f","title":"volitale会一直嗅探 cas 不断循环无效交互 导致带宽达到峰值"}],"id":"3e62670c5d38","title":"MESI"},{"parent":"5b8ac720af41","children":[{"parent":"d09009af451f","children":[],"id":"ded7038f27ff","title":"高速缓存"}],"id":"d09009af451f","title":"Java内存模型JMM"},{"parent":"5b8ac720af41","children":[{"parent":"0ed2fc388dfe","children":[{"parent":"77afeb3ed715","children":[],"id":"ac78b1b05b3e","title":"处理器嗅探总线"}],"id":"77afeb3ed715","title":"嗅探机制 强制失效"}],"id":"0ed2fc388dfe","title":"可见性"},{"parent":"5b8ac720af41","children":[{"parent":"92b8f1fb2082","children":[{"parent":"1d25c5cae485","children":[{"parent":"8f28d3563b12","children":[],"id":"818affd4f910","title":"源代码-&gt;编译器优化重排序-&gt;指令级并行重排序-&gt;内存系统重排序-&gt;最终执行的指令序列"}],"id":"8f28d3563b12","title":"lock 前缀指令 内存屏障"}],"id":"1d25c5cae485","title":"禁止指令重排序"},{"parent":"92b8f1fb2082","children":[{"parent":"ed71f4aec87c","children":[],"id":"41b5f31527d6","title":"volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。"}],"id":"ed71f4aec87c","title":"happens-before"},{"parent":"92b8f1fb2082","children":[],"id":"79dee2abb31e","title":"as-if-serial"}],"id":"92b8f1fb2082","title":"有序性"},{"parent":"5b8ac720af41","children":[],"id":"46aabb045d4f","title":"AtomicInteger"},{"parent":"5b8ac720af41","children":[],"id":"8440ca60dd7f","title":"跳出死循环"}],"id":"5b8ac720af41","title":"volatile"},{"parent":"c28281419b7b","children":[{"parent":"6cedc4907e89","children":[],"id":"9e0b5fc63f06","title":"newFixedThreadPool"},{"parent":"6cedc4907e89","children":[{"parent":"f3ac0f4e3e93","children":[],"id":"745f5d8f76ca","title":"SynchronousQueue"}],"id":"f3ac0f4e3e93","title":"newCacheThreadPool"},{"parent":"6cedc4907e89","children":[],"id":"26e48815adab","title":"newSIngleTheadExecutor"},{"parent":"6cedc4907e89","children":[{"parent":"07c60cd95d03","children":[],"id":"ad60d9af73a1","title":"DelayedWorkQueue"}],"id":"07c60cd95d03","title":"newScheduledThewadPool"},{"parent":"6cedc4907e89","children":[],"id":"6082ba15a1e8","title":"newWorkStealingPool"},{"parent":"6cedc4907e89","children":[],"id":"516507fea9fe","title":"ThreadPoolExecutor"},{"parent":"6cedc4907e89","children":[{"parent":"f454382ecd19","children":[{"parent":"376ab2d9eddc","children":[],"id":"274798d1bc48","title":"默认没线程等任务来了才调用 除非调用了 预创建线程&nbsp; 一个或者全部"}],"id":"376ab2d9eddc","title":"核心线程数"},{"parent":"f454382ecd19","children":[],"id":"47d813b8b728","title":"最大线程数"},{"parent":"f454382ecd19","children":[{"parent":"a17ccf8d354d","children":[],"id":"afd674827d45","title":"没有执行任务多久会终止 当线程池的线程数大于核心线程才会起作用&nbsp; 调用allowCoreThreadTimeOut会起作用"}],"id":"a17ccf8d354d","title":"空闲时间&amp;单位"},{"parent":"f454382ecd19","children":[{"parent":"d495f9692949","children":[{"parent":"f011c4e6dc42","children":[],"id":"48cbe470551e","title":"无界 当心内存溢出"}],"id":"f011c4e6dc42","title":"LinkedBlockingQueue"},{"parent":"d495f9692949","children":[{"parent":"0d043beb5c67","children":[],"id":"60f3191802b7","title":"有界队列"},{"parent":"0d043beb5c67","children":[],"id":"f2944b742680","title":"加锁保证安全&nbsp; 一直死循环阻塞 队列不满就唤醒"},{"parent":"0d043beb5c67","children":[{"parent":"38d091049ecc","children":[],"id":"6eb55f5fc9c8","title":"阻塞调用方式 put(e)或 offer(e, timeout, unit)<br>阻塞调用时，唤醒条件为超时或者队列非满（因此，要求在出队时，要发起一个唤醒操作）<br>进队成功之后，执行notEmpty.signal()唤起被阻塞的出队线程"},{"parent":"38d091049ecc","children":[],"id":"7842cc996186","title":"在进行某项业务存储操作时，建议采用offer进行添加，可及时获取boolean进行判断，如用put要考虑阻塞情况（队列的出队操作慢于进队操作），资源占用。"}],"id":"38d091049ecc","title":"入队"}],"id":"0d043beb5c67","title":"ArrayBlockingQueue"},{"parent":"d495f9692949","children":[],"id":"3823de3830d6","title":"Synchronous"}],"id":"d495f9692949","title":"缓冲队列"},{"parent":"f454382ecd19","children":[],"id":"828115fd14dd","title":"工厂方法"},{"parent":"f454382ecd19","children":[{"parent":"ffaba8069da5","children":[],"id":"30aa50211e97","title":"抛异常"},{"parent":"ffaba8069da5","children":[],"id":"8d3806dc114d","title":"丢弃"},{"parent":"ffaba8069da5","children":[],"id":"26ee9a5c14f5","title":"重试"},{"parent":"ffaba8069da5","children":[],"id":"13f52a2db26a","title":"丢弃最早提交的"}],"id":"ffaba8069da5","title":"拒绝策略"},{"parent":"f454382ecd19","children":[],"id":"8acc26758c43","title":"使用Has表维护线程的引用"},{"parent":"f454382ecd19","children":[{"parent":"7966a8cbe67d","children":[],"id":"a64cacfeac16","title":"使用future获取任务的执行结果"}],"id":"7966a8cbe67d","title":"submit"}],"id":"f454382ecd19","title":"参数意义"},{"parent":"6cedc4907e89","children":[{"parent":"cf531279d59e","children":[],"id":"913f3668987c","title":"商品详情界面"},{"parent":"cf531279d59e","children":[],"id":"68f9a5eda444","title":"批处理"}],"id":"cf531279d59e","title":"实际使用"},{"parent":"6cedc4907e89","children":[{"parent":"40a94e5b2caf","children":[],"id":"c2d49628d444","title":"核心线程-&gt;队列-&gt;最大线程-&gt;拒绝策略"}],"id":"40a94e5b2caf","title":"执行过程"},{"parent":"6cedc4907e89","children":[{"parent":"f98ba5af6235","children":[{"parent":"d51a98f65758","children":[],"id":"8206e42603b6","title":"running"},{"parent":"d51a98f65758","children":[],"id":"f4c1c0097829","title":"shutdown"},{"parent":"d51a98f65758","children":[],"id":"67fb7231e55d","title":"stop"},{"parent":"d51a98f65758","children":[{"parent":"3779e0a775c5","children":[],"id":"7ed5f9451f25","title":"所有线程销毁"}],"id":"3779e0a775c5","title":"terminated"}],"id":"d51a98f65758","title":"有个Volatile的状态码"},{"parent":"f98ba5af6235","children":[],"id":"6a80cee42cc2","title":"corePoolSize、maximumPoolSize、largestPoolSize 有意思"}],"id":"f98ba5af6235","title":"运行状态"},{"parent":"6cedc4907e89","children":[],"id":"9b75cca777e0","title":"故障"}],"id":"6cedc4907e89","title":"线程池"},{"parent":"c28281419b7b","children":[],"id":"7c4b973b7055","title":"JUC"},{"parent":"c28281419b7b","children":[{"parent":"1db857c125f3","children":[{"parent":"fa9752dbce4c","children":[],"id":"46ff68fb3045","title":"主要可以介绍一下 wait/notify 机制，共享变量的 synchronized 或者 Lock 同步机制等。<br>"},{"parent":"fa9752dbce4c","children":[],"id":"5b33b1897a11","title":"volatile"},{"parent":"fa9752dbce4c","children":[],"id":"f99a436512ec","title":"CountDownLatch"},{"parent":"fa9752dbce4c","children":[],"id":"85e4c97a90b6","title":"CyclicBarrier"}],"id":"fa9752dbce4c","title":"线程间是怎么进行通信的？"},{"parent":"1db857c125f3","children":[{"parent":"72a95a2e4054","children":[],"id":"5bcc222b5587","title":"可以从尽量减少临界区范围，使用 ThreadLocal，减少线程切换、使用读写锁或 copyonwrite 等机制这些方面来回答。<br>"}],"id":"72a95a2e4054","title":"ThreadLocal 用来解决什么问题？"},{"parent":"1db857c125f3","children":[{"parent":"dc90dacb4560","children":[],"id":"2189dcf10578","title":"ThreadLocal 是如何实现的？可以重点回答 ThreadLocal 不是用来解决多线程共享变量的问题，而是用来解决线程数据隔离"}],"id":"dc90dacb4560","title":"如何尽可能提高多线程并发性能？"},{"parent":"1db857c125f3","children":[{"parent":"640e0e293c95","children":[],"id":"c5d9df173a04","title":"可以回答读写锁适合读并发多，写并发少的场景，另外一个解决这种场景的方法是 copyonwrite。"}],"id":"640e0e293c95","title":"读写锁适用于什么场景？"},{"parent":"1db857c125f3","children":[{"parent":"7449e9c1c25d","children":[],"id":"90b62a363909","title":"可以尝试通过锁、信号量、线程通信、阻塞队列等不同方式实现。"}],"id":"7449e9c1c25d","title":"如何实现一个生产者与消费者模型？"}],"id":"1db857c125f3","title":"常见问题"},{"parent":"c28281419b7b","children":[{"parent":"f7db15528de4","children":[{"parent":"773c32271aab","children":[],"id":"5d513d3ea851","title":"start"},{"parent":"773c32271aab","children":[],"id":"471cf42d0f9d","title":"sleep休眠超时"}],"id":"773c32271aab","title":"线程就绪"}],"id":"f7db15528de4","title":"线程状态"},{"parent":"c28281419b7b","children":[{"parent":"7964df486fe4","children":[],"id":"fc224e79458d","title":"只有一个构造方法 只会被赋值一次"},{"parent":"7964df486fe4","children":[],"id":"477f82a6bce7","title":"没有别的方法可以修改 count"}],"id":"7964df486fe4","title":"countDownLatch"}],"collapsed":false,"id":"c28281419b7b","title":"多线程"},{"parent":"root","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"parent":"f49b1c2ccde2","children":[{"parent":"c6d08f035d63","children":[],"id":"5e7761064fce","title":"堆"},{"parent":"c6d08f035d63","children":[],"id":"4a6fdcd99a9a","title":"栈"},{"parent":"c6d08f035d63","children":[],"id":"a15013445f25","title":"方法区"},{"parent":"c6d08f035d63","children":[],"id":"a2bd0be13dfc","title":"本地方法栈<br>"},{"parent":"c6d08f035d63","children":[],"id":"5d8e758ed4b6","title":"程序计数器"}],"id":"c6d08f035d63","title":"JVM内存模型"},{"parent":"f49b1c2ccde2","children":[{"parent":"d7ec146aa8d2","children":[],"id":"bbacf65508c4","title":"加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载"},{"parent":"d7ec146aa8d2","children":[{"parent":"4bd3c929b6bc","children":[],"id":"0d4c8dbdc401","title":"父类加载 不重复加载"}],"id":"4bd3c929b6bc","title":"双亲委派原则"}],"id":"d7ec146aa8d2","title":"类加载机制"},{"parent":"f49b1c2ccde2","children":[{"parent":"3b72ddae62db","children":[{"parent":"d15d75bf35b3","children":[],"id":"8fae28f21ad9","title":"Eden/s1/s2"}],"id":"d15d75bf35b3","title":"年轻代"},{"parent":"3b72ddae62db","children":[],"id":"ea0d9dcd32fd","title":"老年代"},{"parent":"3b72ddae62db","children":[],"id":"6ed4fd696d04","title":"永久代/元空间"},{"parent":"3b72ddae62db","children":[{"parent":"077a7a6cbfd3","children":[],"id":"38e9fe09a44f","title":"根据存活时间"}],"id":"077a7a6cbfd3","title":"晋升机制"}],"id":"3b72ddae62db","title":"分代回收"},{"parent":"f49b1c2ccde2","children":[{"parent":"96caf50029e5","children":[{"parent":"79420da3a9ad","children":[{"parent":"4715917873f1","children":[],"id":"be3dd3b11fac","title":"对象存活比较多的时候适用"},{"parent":"4715917873f1","children":[],"id":"2dbbb54ddf73","title":"老年代"}],"id":"4715917873f1","title":"适用场景"},{"parent":"79420da3a9ad","children":[{"parent":"2583e07d35c6","children":[],"id":"da220ffd822e","title":"提前GC"},{"parent":"2583e07d35c6","children":[],"id":"596fbb85c2fb","title":"碎片空间"},{"parent":"2583e07d35c6","children":[{"parent":"cf19e8de34fa","children":[],"id":"0ea6303bcb1c","title":"标记存活对象"},{"parent":"cf19e8de34fa","children":[],"id":"0d0001b76a8e","title":"清除没有标记的对象"}],"id":"cf19e8de34fa","title":"扫描了两次"}],"id":"2583e07d35c6","title":"缺点"}],"id":"79420da3a9ad","title":"标记清除"},{"parent":"96caf50029e5","children":[{"parent":"981ef863aade","children":[{"parent":"1d32fa80a1c7","children":[],"id":"b5600851afd1","title":"存活对象少 比较高效"},{"parent":"1d32fa80a1c7","children":[],"id":"5b9c3e06ff3a","title":"扫描了整个空间（标记存活对象并复制异动）"},{"parent":"1d32fa80a1c7","children":[],"id":"0f19d7e38e0a","title":"适合年轻代"}],"id":"1d32fa80a1c7","title":"适合场景"},{"parent":"981ef863aade","children":[{"parent":"e3639c5ef0ad","children":[],"id":"bb47867f4325","title":"需要空闲空间"},{"parent":"e3639c5ef0ad","children":[],"id":"bd14ca33efb9","title":"需要复制移动对象"}],"id":"e3639c5ef0ad","title":"缺点"}],"id":"981ef863aade","title":"标记复制"},{"parent":"96caf50029e5","children":[{"parent":"de1d4a3ff1b4","children":[],"id":"b014a27b243d","title":"没办法解决循环引用的问题"}],"id":"de1d4a3ff1b4","title":"引用计数"},{"parent":"96caf50029e5","children":[],"id":"942c3ebc9f77","title":"标记整理"}],"id":"96caf50029e5","title":"垃圾回收机制"},{"parent":"f49b1c2ccde2","children":[{"parent":"c1d30770de62","children":[{"parent":"17d02bc8ddac","children":[{"parent":"0765f0db41a5","children":[{"parent":"18d3721fe043","children":[],"id":"016b4fd02b34","title":"edan","summaries":[]},{"parent":"18d3721fe043","children":[],"id":"979e65d7998a","title":"s1","summaries":[]},{"parent":"18d3721fe043","children":[],"id":"de946519d4fb","title":"s2"},{"parent":"18d3721fe043","children":[{"parent":"6887519dff74","children":[],"id":"4cb9f7edb3b8","title":"通过阈值晋升"}],"id":"6887519dff74","title":"minor gc"}],"id":"18d3721fe043","title":"年轻"},{"parent":"0765f0db41a5","children":[{"parent":"391b45371fc4","children":[],"id":"4559ce982a00","title":"major gc 等价于 full gc"}],"id":"391b45371fc4","title":"老年"},{"parent":"0765f0db41a5","children":[],"id":"61bbe29c6512","title":"永久"}],"id":"0765f0db41a5","title":"分代"},{"parent":"17d02bc8ddac","children":[{"parent":"586d986b310a","children":[],"id":"a1e7cd5490f2","title":"对cpu资源敏感"},{"parent":"586d986b310a","children":[],"id":"9cd5c808b3b9","title":"无法处理浮动垃圾"},{"parent":"586d986b310a","children":[],"id":"6486e3c04ed3","title":"基于标记清除算法 大量空间碎片"}],"id":"586d986b310a","title":"缺点"}],"id":"17d02bc8ddac","title":"CMS"},{"parent":"c1d30770de62","children":[{"parent":"672d9b9090c1","children":[],"id":"cb5c73a71e23","title":"分区概念 弱化分代"},{"parent":"672d9b9090c1","children":[],"id":"1b8e7a46bd1b","title":"标记整理算法 不会产生空间碎片 分配大对象不会提前full gc"},{"parent":"672d9b9090c1","children":[],"id":"4202d15cc655","title":"可以设置预设停顿时间"},{"parent":"672d9b9090c1","children":[],"id":"8e84fe34bed5","title":"充分利用cpu 多核条件下 缩短stw","summaries":[]},{"parent":"672d9b9090c1","children":[{"parent":"59fef4addd01","children":[],"id":"5474f48ef78f","title":"初始标记 stw 从gc root 开始直接可达的对象"},{"parent":"59fef4addd01","children":[{"parent":"eacaf0c159c7","children":[],"id":"f725b6cb0a9e","title":"可达性分析算法"}],"id":"eacaf0c159c7","title":"并发标记 gc root 对对象进行可达性分析 找出存活对象"},{"parent":"59fef4addd01","children":[],"id":"c63d10846264","title":"最终标记"},{"parent":"59fef4addd01","children":[{"parent":"3505ab102705","children":[],"id":"6108af8d5789","title":"根据用户期待的gc停顿时间指定回收计划"}],"id":"3505ab102705","title":"筛选回收"}],"id":"59fef4addd01","title":"收集步骤"},{"parent":"672d9b9090c1","children":[{"parent":"d32bafadec08","children":[{"parent":"26455db7f4ab","children":[{"parent":"63c283692e6b","children":[],"id":"0e44402a2c59","title":"复制一些存活对象到old区s区"}],"id":"63c283692e6b","title":"回收所有的eden s区"}],"id":"26455db7f4ab","title":"young gc"},{"parent":"d32bafadec08","children":[],"id":"a00b1e3b59ca","title":"mixed gc"}],"id":"d32bafadec08","title":"回收模式"},{"parent":"672d9b9090c1","children":[],"id":"f76501a14c6f","title":"GC模式"}],"id":"672d9b9090c1","title":"G1"},{"parent":"c1d30770de62","children":[{"parent":"57f1b7248730","children":[],"id":"98819b716909","title":"g1分区域 每个区域是有老年代概念的 但是收集器以整个区域为单位收集"},{"parent":"57f1b7248730","children":[],"id":"bca5d0da5ab1","title":"g1回收后马上合并空闲内存&nbsp; cms 在stw的时候做"}],"id":"57f1b7248730","title":"区别"},{"parent":"c1d30770de62","children":[{"parent":"0d259a1c4535","children":[],"id":"45774f76ce55","title":"XX:G1HeapRegionSize"},{"parent":"0d259a1c4535","children":[],"id":"161ca034c81e","title":"复制成活对象到一个区域 暂停所有线程"}],"id":"0d259a1c4535","title":"内存区域设置"}],"id":"c1d30770de62","title":"垃圾回收器"},{"parent":"f49b1c2ccde2","children":[{"parent":"c26032412d0a","children":[],"id":"946486ee3610","title":"老年代写满"},{"parent":"c26032412d0a","children":[],"id":"e44097408048","title":"system。gc"},{"parent":"c26032412d0a","children":[],"id":"72cf1ab426f3","title":"持久代空间不足"}],"id":"c26032412d0a","title":"full gc"},{"parent":"f49b1c2ccde2","children":[],"id":"94a0df6a382f","title":"STW"},{"parent":"f49b1c2ccde2","children":[{"parent":"480d6f5f528f","children":[{"parent":"cc604520068c","children":[],"id":"2417e9ec46b0","title":"设置堆的最大最小值 -xms -xmx"},{"parent":"cc604520068c","children":[{"parent":"9edf21454f2d","children":[{"parent":"a1da74180b66","children":[],"id":"210f23444e49","title":"防止年轻代堆收缩：老年代同理"}],"id":"a1da74180b66","title":"-XX:newSize设置绝对大小"}],"id":"9edf21454f2d","title":"调整老年和年轻代的比例"},{"parent":"cc604520068c","children":[],"id":"7ae4c6d0d47c","title":"主要看是否存在更多持久对象和临时对象"},{"parent":"cc604520068c","children":[],"id":"c31b43d85afc","title":"观察一段时间 看峰值老年代如何 不影响gc就加大年轻代"},{"parent":"cc604520068c","children":[],"id":"4d9a65801c2e","title":"配置好的机器可以用 并发收集算法"},{"parent":"cc604520068c","children":[],"id":"1e8faba84ce2","title":"每个线程默认会开启1M的堆栈 存放栈帧 调用参数 局部变量 太大了&nbsp; 500k够了"},{"parent":"cc604520068c","children":[],"id":"c2b7e057e7ed","title":"原则 就是减少gc stw"}],"id":"cc604520068c","title":"性能调优"},{"parent":"480d6f5f528f","children":[{"parent":"5d86ec425c3c","children":[],"id":"7cb2d0919222","title":"jasvism"},{"parent":"5d86ec425c3c","children":[],"id":"1937ddc1f161","title":"dump"},{"parent":"5d86ec425c3c","children":[],"id":"ab74b78ad982","title":"监控配置 自动dump"}],"id":"5d86ec425c3c","title":"FullGC 内存泄露排查"}],"id":"480d6f5f528f","title":"实战"},{"parent":"f49b1c2ccde2","children":[],"id":"8a4dff219580","title":"oom种类"},{"parent":"f49b1c2ccde2","children":[],"id":"05cd69ed98f8","title":"逃逸分析"},{"parent":"f49b1c2ccde2","children":[{"parent":"d08628bcec95","children":[],"id":"6704c29c0f05","title":"虚拟机栈（栈帧中的本地变量表）中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量变量引用的对象<br>本地方法栈中JNI（即一般说的Native方法）引用的对象<br>活跃线程的引用对象"}],"id":"d08628bcec95","title":"可达性"},{"parent":"f49b1c2ccde2","children":[{"parent":"6f4de6876975","children":[],"id":"ad678607968f","title":"OOM"},{"parent":"6f4de6876975","children":[],"id":"e2c6e344aa5b","title":"内存泄露"},{"parent":"6f4de6876975","children":[],"id":"aa247f267224","title":"线程死锁"},{"parent":"6f4de6876975","children":[],"id":"8d332817b2a1","title":"锁争用"},{"parent":"6f4de6876975","children":[],"id":"77c0385d61b3","title":"Java进程消耗CPU过高"}],"id":"6f4de6876975","title":"JVM调优"},{"parent":"f49b1c2ccde2","children":[{"parent":"b4f3becde6d7","children":[],"id":"ef582c3853fd","title":"Jconsole"},{"parent":"b4f3becde6d7","children":[],"id":"1ad64c3a38ee","title":"Jprofiler"},{"parent":"b4f3becde6d7","children":[],"id":"2a4c4f213549","title":"jvisualvm"},{"parent":"b4f3becde6d7","children":[],"id":"a01f1f9a9fa4","title":"MAT"}],"id":"b4f3becde6d7","title":"JVM性能检测工具"},{"parent":"f49b1c2ccde2","children":[{"parent":"777c59e011d0","children":[],"id":"ec99856c3a58","title":"help dump"},{"parent":"777c59e011d0","children":[],"id":"6dd1f807983a","title":"生产机 dump"},{"parent":"777c59e011d0","children":[],"id":"cc90e57af77a","title":"mat"},{"parent":"777c59e011d0","children":[],"id":"e594d92c9ce0","title":"jmap"},{"parent":"777c59e011d0","children":[],"id":"1eb1502ab98b","title":"-helpdump"}],"id":"777c59e011d0","title":"内存泄露"},{"parent":"f49b1c2ccde2","children":[{"parent":"2497f83b1289","children":[],"id":"d333f14757f5","title":"topc -c"},{"parent":"2497f83b1289","children":[],"id":"4142c6675fbc","title":"top -Hp pid"},{"parent":"2497f83b1289","children":[{"parent":"1ab0a36e9180","children":[],"id":"8c241e3ba551","title":"进制转换"}],"id":"1ab0a36e9180","title":"jstack"},{"parent":"2497f83b1289","children":[],"id":"6a18e2c403b2","title":"cat<br>"}],"id":"2497f83b1289","title":"CPU100%"}],"collapsed":true,"id":"f49b1c2ccde2","title":"JVM"},{"parent":"root","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"parent":"7b948a534f4c","children":[{"parent":"2f62b32ca96d","children":[],"id":"9b8dbd6264eb","title":"单例"},{"parent":"2f62b32ca96d","children":[],"id":"42f2ee0b257e","title":"工厂"},{"parent":"2f62b32ca96d","children":[{"parent":"392cd1d6a881","children":[],"id":"57f65b7e5d7a","title":"根据不同商家适配"}],"id":"392cd1d6a881","title":"适配器"},{"parent":"2f62b32ca96d","children":[{"parent":"aa4c5a4ba4cb","children":[],"id":"7bbdfb8a22ce","title":"继承&nbsp; process 链路执行"}],"id":"aa4c5a4ba4cb","title":"责任链"}],"id":"2f62b32ca96d","title":"设计模式"},{"parent":"7b948a534f4c","children":[],"id":"728b7a7d0106","title":"源码"},{"parent":"7b948a534f4c","children":[{"parent":"eadeb250eeb7","children":[{"parent":"e3f713ccfea9","children":[{"parent":"6139b5009da3","children":[],"id":"401a8bdefe79","title":"invokeBeanFactoryPostProcessors"}],"id":"6139b5009da3","title":"扫描类"},{"parent":"e3f713ccfea9","children":[],"id":"7ac2d28beea4","title":"封装beanDefinition对象&nbsp; 各种信息"},{"parent":"e3f713ccfea9","children":[],"id":"64572a81f76f","title":"放到map"},{"parent":"e3f713ccfea9","children":[],"id":"58bdd2d31769","title":"遍历map"},{"parent":"e3f713ccfea9","children":[{"parent":"e19d93b93a26","children":[],"id":"bf5720d5bd02","title":"能不能实例化 需要实例化么 根据信息来"},{"parent":"e19d93b93a26","children":[],"id":"1455f8595a32","title":"是否单例等等"},{"parent":"e19d93b93a26","children":[],"id":"462288a5c498","title":"判断是不是factory bean"},{"parent":"e19d93b93a26","children":[],"id":"838463db5ea8","title":"单例池&nbsp; 只是一个ConcurrentHashMap而已"},{"parent":"e19d93b93a26","children":[],"id":"b09b7bb6e0f5","title":"正在创建的 容器"}],"id":"e19d93b93a26","title":"验证"},{"parent":"e3f713ccfea9","children":[],"id":"fb259297b1e0","title":"得到 class"},{"parent":"e3f713ccfea9","children":[{"parent":"29dd111d2305","children":[],"id":"599b122e44c6","title":"根据注入模型"},{"parent":"29dd111d2305","children":[],"id":"ca16bb02246d","title":"默认"}],"id":"29dd111d2305","title":"推断构造方法"},{"parent":"e3f713ccfea9","children":[],"id":"9ea7c0b8fab5","title":"得到构造方法"},{"parent":"e3f713ccfea9","children":[],"id":"ddc01dc2d6ce","title":"反射 实例化这个对象"},{"parent":"e3f713ccfea9","children":[],"id":"40040ef9f993","title":"后置处理器合并beanDefinition"},{"parent":"e3f713ccfea9","children":[],"id":"0ec224be0eb8","title":"判断是否允许 循环依赖"},{"parent":"e3f713ccfea9","children":[],"id":"322b454b4310","title":"提前暴露bean工厂对象"},{"parent":"e3f713ccfea9","children":[{"parent":"f0462922a3c3","children":[],"id":"2ba3d6084c36","title":"自动注入"}],"id":"f0462922a3c3","title":"填充属性"},{"parent":"e3f713ccfea9","children":[],"id":"7d59119d9af3","title":"执行部分 aware 接口"},{"parent":"e3f713ccfea9","children":[],"id":"e08cd806bc91","title":"继续执行部分 aware 接口 生命周期回调方法"},{"parent":"e3f713ccfea9","children":[],"id":"63a572ffacec","title":"完成代理AOP"},{"parent":"e3f713ccfea9","children":[],"id":"3d05f3d37dd0","title":"beanProstprocessor 的前置方法"},{"parent":"e3f713ccfea9","children":[],"id":"bb1974342b9d","title":"实例化为bean"},{"parent":"e3f713ccfea9","children":[],"id":"a53841f00fcf","title":"放到单例池"},{"parent":"e3f713ccfea9","children":[],"id":"b1e34432d74a","title":"销毁"}],"id":"e3f713ccfea9","title":"生命周期"},{"parent":"eadeb250eeb7","children":[{"parent":"06ce49f43ce3","children":[],"id":"e30acc5e49c2","title":"单例（singleton）"},{"parent":"06ce49f43ce3","children":[],"id":"3b06446155e0","title":"多例（prototype）"},{"parent":"06ce49f43ce3","children":[],"id":"d6300fcd1136","title":"Request"},{"parent":"06ce49f43ce3","children":[],"id":"c6c9350ba496","title":"Session"}],"id":"06ce49f43ce3","title":"作用域"}],"id":"eadeb250eeb7","title":"Bean"},{"parent":"7b948a534f4c","children":[{"parent":"c143613641cb","children":[{"parent":"f336d4b71b6c","children":[],"id":"ec465762826e","title":"属性注入可以破解"},{"parent":"f336d4b71b6c","children":[{"parent":"1e3cb6ee5770","children":[],"id":"0df2d9a8ef59","title":"三级缓存没自己 因二级之后去加载B了"}],"id":"1e3cb6ee5770","title":"构造器不行"}],"id":"f336d4b71b6c","title":"情况"},{"parent":"c143613641cb","children":[{"parent":"4302973d31ed","children":[],"id":"f3fdfeec3597","title":"去单例池拿"},{"parent":"4302973d31ed","children":[],"id":"c168eceb8e1e","title":"判断是不是正在被创建的"},{"parent":"4302973d31ed","children":[],"id":"4534d8d91514","title":"判断是否 支持循环依赖"},{"parent":"4302973d31ed","children":[],"id":"a0f96d7985c0","title":"二级缓存 放到 三级缓存"},{"parent":"4302973d31ed","children":[{"parent":"5a8c890d1b1e","children":[],"id":"25ac9c8ed668","title":"GC"}],"id":"5a8c890d1b1e","title":"干掉二级缓存"},{"parent":"4302973d31ed","children":[],"id":"fdcd482ba84d","title":"下次再来直接 三级缓存拿 缓存"}],"id":"4302973d31ed","title":"三级缓存"},{"parent":"c143613641cb","children":[{"parent":"ae5677708dcd","children":[],"id":"2d294cc46f66","title":"一级缓存 单例Bean"},{"parent":"ae5677708dcd","children":[{"parent":"a39e851c6a77","children":[],"id":"76e86d0ff353","title":"产生bean 复杂"}],"id":"a39e851c6a77","title":"二级缓存 工厂 产生baen"},{"parent":"ae5677708dcd","children":[],"id":"e95b3cd15692","title":"三级缓存&nbsp; 半成品"}],"id":"ae5677708dcd","title":"缓存 存放"}],"id":"c143613641cb","title":"循环依赖"},{"parent":"7b948a534f4c","children":[],"id":"bac4563cdffb","title":"父子容器"},{"parent":"7b948a534f4c","children":[{"parent":"89fdf18bfa1d","children":[],"id":"355578f185eb","title":"采用不同的连接器"},{"parent":"89fdf18bfa1d","children":[{"parent":"8f1ed4ff6831","children":[],"id":"e98b16966907","title":"共享链接"}],"id":"8f1ed4ff6831","title":"用AOP 新建立了一个 链接"},{"parent":"89fdf18bfa1d","children":[],"id":"c94f88c41bed","title":"ThreadLocal 当前事务"},{"parent":"89fdf18bfa1d","children":[],"id":"721325c1624e","title":"前提是 关闭AutoCommit"}],"id":"89fdf18bfa1d","title":"事务实现原理"},{"parent":"7b948a534f4c","children":[{"parent":"afeb4a5d70a9","children":[{"parent":"ba6a1d18bc97","children":[],"id":"026b57552c5b","title":"实现类"}],"id":"ba6a1d18bc97","title":"静态代理"},{"parent":"afeb4a5d70a9","children":[{"parent":"cda832a46fcc","children":[{"parent":"bf6b4e2a9d57","children":[{"parent":"461270f92911","children":[{"parent":"19c1ec9f17ab","children":[],"id":"64c983346345","title":"调用具体方法的时候调用invokeHandler"}],"id":"19c1ec9f17ab","title":"java反射机制生成一个代理接口的匿名类"}],"id":"461270f92911","title":"实现接口"}],"id":"bf6b4e2a9d57","title":"JDK动态代理"},{"parent":"cda832a46fcc","children":[{"parent":"f59fbb0d93d3","children":[{"parent":"f7034de6eebd","children":[],"id":"5629102f02fe","title":"修改字节码生成子类去处理"}],"id":"f7034de6eebd","title":"asm字节码编辑技术动态创建类 基于classLoad装载"}],"id":"f59fbb0d93d3","title":"cjlib"}],"id":"cda832a46fcc","title":"动态代理"}],"id":"afeb4a5d70a9","title":"AOP"},{"parent":"7b948a534f4c","children":[],"id":"2f5a2ae58993","title":"IOC"},{"parent":"7b948a534f4c","children":[{"parent":"c447c3798a3f","children":[{"parent":"ec9319e9a640","children":[{"parent":"1c3519b20067","children":[],"id":"79b9ea040fac","title":"生成一个class对象"}],"id":"1c3519b20067","title":"加载"},{"parent":"ec9319e9a640","children":[{"parent":"ff8cbfeb019b","children":[],"id":"b59fef90f1e4","title":"文件格式验证"},{"parent":"ff8cbfeb019b","children":[],"id":"f948761b5c0a","title":"元数据验证"},{"parent":"ff8cbfeb019b","children":[],"id":"02bd00dc6ba4","title":"字节码验证"},{"parent":"ff8cbfeb019b","children":[],"id":"f6df504cf2b7","title":"符号引用验证"}],"id":"ff8cbfeb019b","title":"验证"},{"parent":"ec9319e9a640","children":[{"parent":"f32b0307eac0","children":[],"id":"0ca4242640d6","title":"默认值"},{"parent":"f32b0307eac0","children":[],"id":"46ca7a9e9dc3","title":"static会分配内存"}],"id":"f32b0307eac0","title":"准备"},{"parent":"ec9319e9a640","children":[{"parent":"9de4680c9b60","children":[{"parent":"842c0bf40ee8","children":[],"id":"852a661fb748","title":"引用等"}],"id":"842c0bf40ee8","title":"解析具体类的信息"}],"id":"9de4680c9b60","title":"解析"},{"parent":"ec9319e9a640","children":[{"parent":"2ec2b835e427","children":[],"id":"7dd810acab8a","title":"父类没初始化 先初始化父类"}],"id":"2ec2b835e427","title":"初始化"},{"parent":"ec9319e9a640","children":[],"id":"fc11d33ac69a","title":"使用"},{"parent":"ec9319e9a640","children":[],"id":"1ce183d09299","title":"卸载"}],"id":"ec9319e9a640","title":"过程"},{"parent":"c447c3798a3f","children":[{"parent":"2b7064f5cc23","children":[],"id":"51ad637dc0b6","title":"main（）"},{"parent":"2b7064f5cc23","children":[],"id":"c184c454b511","title":"class。forName"},{"parent":"2b7064f5cc23","children":[],"id":"3ec0516f5a74","title":"ClassLoader。loadClass"}],"id":"2b7064f5cc23","title":"加载方式"},{"parent":"c447c3798a3f","children":[{"parent":"84fcee6e7baf","children":[],"id":"2867d26a4ee4","title":"Appclass Loade"},{"parent":"84fcee6e7baf","children":[],"id":"d4b827d172b0","title":"Extention ClassLoader"},{"parent":"84fcee6e7baf","children":[],"id":"35008d30487b","title":"Bootstrap ClassLoader"}],"id":"84fcee6e7baf","title":"类加载器"},{"parent":"c447c3798a3f","children":[{"parent":"2bbf8b7aae3a","children":[],"id":"95b28973aa81","title":"可以避免重复加载"},{"parent":"2bbf8b7aae3a","children":[],"id":"46c628815b24","title":"安全"}],"id":"2bbf8b7aae3a","title":"双亲委派原则"}],"id":"c447c3798a3f","title":"类加载机制"}],"collapsed":true,"id":"7b948a534f4c","title":"Spring"},{"parent":"root","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"parent":"c6ed55dfc9e7","children":[{"parent":"fd7ebaed743d","children":[],"id":"6bf16796c231","title":"String"},{"parent":"fd7ebaed743d","children":[],"id":"63c4bcdd042d","title":"Hash"},{"parent":"fd7ebaed743d","children":[],"id":"c864b58db01b","title":"set"},{"parent":"fd7ebaed743d","children":[{"parent":"ebd16975e7af","children":[],"id":"0a0f455e065e","title":"score"},{"parent":"ebd16975e7af","children":[{"parent":"4a68cd3cacf4","children":[],"id":"dee6fa5bbd88","title":"只需要调整前后节点指针"}],"id":"4a68cd3cacf4","title":"随机层数"},{"parent":"ebd16975e7af","children":[{"parent":"476d459916f2","children":[],"id":"123795c60e85","title":"还会比较value"}],"id":"476d459916f2","title":"不止比较score"},{"parent":"ebd16975e7af","children":[{"parent":"e97e00a0248a","children":[],"id":"cae4de077445","title":"成绩"},{"parent":"e97e00a0248a","children":[],"id":"d51e9d7ffb4c","title":"积分"},{"parent":"e97e00a0248a","children":[],"id":"3f18bd21bc19","title":"排行榜"}],"id":"e97e00a0248a","title":"场景"}],"id":"ebd16975e7af","title":"zset"},{"parent":"fd7ebaed743d","children":[{"parent":"e765fe49dbf9","children":[],"id":"220f7bb1ba99","title":"分页的坑"}],"id":"e765fe49dbf9","title":"List"},{"parent":"fd7ebaed743d","children":[],"id":"697fb306e3c4","title":"HyperLogLog"},{"parent":"fd7ebaed743d","children":[],"id":"637bd200c571","title":"Geo"},{"parent":"fd7ebaed743d","children":[],"id":"6306c1b79580","title":"Pub/Sub"},{"parent":"fd7ebaed743d","children":[],"id":"5d9dbb2a44ce","title":"BitMap"},{"parent":"fd7ebaed743d","children":[{"parent":"d12bd399b32f","children":[{"parent":"4b0e86eb6a74","children":[],"id":"e96f55932a91","title":"键值的底层都是SDS"},{"parent":"4b0e86eb6a74","children":[],"id":"55cedd156a57","title":"AOF缓存区"},{"parent":"4b0e86eb6a74","children":[],"id":"15dd77facf88","title":"记录本身长度&nbsp; C需要遍历"},{"parent":"4b0e86eb6a74","children":[{"parent":"65093d7180fe","children":[],"id":"5892d1fabe53","title":"空间预支配"},{"parent":"65093d7180fe","children":[],"id":"32f0503e5e5d","title":"惰性空间释放"}],"id":"65093d7180fe","title":"修改字符减少内存重新分配"},{"parent":"4b0e86eb6a74","children":[{"parent":"c1a623760fbb","children":[],"id":"611ca83eb35c","title":"C只能保存文本数据 无法保存图片等二进制数据"},{"parent":"c1a623760fbb","children":[],"id":"7676e308c143","title":"sds是使用长度去判断"}],"id":"c1a623760fbb","title":"二进制安全"},{"parent":"4b0e86eb6a74","children":[],"id":"be16db092c7d","title":"杜绝缓冲区溢出"},{"parent":"4b0e86eb6a74","children":[],"id":"bd920920eaf5","title":"兼容部分C字符串函数"}],"id":"4b0e86eb6a74","title":"SDS"},{"parent":"d12bd399b32f","children":[{"parent":"20a5a7998929","children":[],"id":"ab91b5ac89a9","title":"保存多个客户端的状态信息"},{"parent":"20a5a7998929","children":[],"id":"5cab4de43f46","title":"列表订阅发布&nbsp; 慢查询&nbsp; 监视器"}],"id":"20a5a7998929","title":"链表"},{"parent":"d12bd399b32f","children":[{"parent":"a428b0f9832e","children":[],"id":"14b3200c09d9","title":"数据库&nbsp; 哈希键"},{"parent":"a428b0f9832e","children":[],"id":"976d79af8573","title":"Hash表节点"},{"parent":"a428b0f9832e","children":[],"id":"8913b4f091c2","title":"hash冲突用单向链表解决"},{"parent":"a428b0f9832e","children":[{"parent":"38e8942bfd41","children":[],"id":"609ba56af5c7","title":"会逐渐rehash 新的键值对全部放到新的hash表"}],"id":"38e8942bfd41","title":"渐进式 rehash"},{"parent":"a428b0f9832e","children":[{"parent":"d20e0c65c399","children":[],"id":"9b75643be299","title":"一个平时用 一个rehash时候用"}],"id":"d20e0c65c399","title":"每个字典带 两个hash表"}],"id":"a428b0f9832e","title":"字典"},{"parent":"d12bd399b32f","children":[],"id":"e83d42c2458e","title":"压缩列表"},{"parent":"d12bd399b32f","children":[],"id":"9b81d0b407fc","title":"整数集合"}],"id":"d12bd399b32f","title":"底层"}],"id":"fd7ebaed743d","title":"数据结构"},{"parent":"c6ed55dfc9e7","children":[{"parent":"e81a545525e5","children":[],"id":"2a878c6b57fa","title":"Keys"},{"parent":"e81a545525e5","children":[],"id":"d637c48ff753","title":"setnx"},{"parent":"e81a545525e5","children":[],"id":"3c6773f2e8c4","title":"exprie"}],"id":"e81a545525e5","title":"常见命令"},{"parent":"c6ed55dfc9e7","children":[{"parent":"834989c97449","children":[{"parent":"0a1bccf42a75","children":[{"parent":"8b3267313a2c","children":[],"id":"aad4177847e6","title":"5分钟一次"},{"parent":"8b3267313a2c","children":[],"id":"9c071c258d1a","title":"冷备"},{"parent":"8b3267313a2c","children":[],"id":"83bd814ac57b","title":"恢复的时候比较快"},{"parent":"8b3267313a2c","children":[],"id":"711fc7ddba81","title":"快照文件生成时间久，消耗cpu"}],"id":"8b3267313a2c","title":"RDB"},{"parent":"0a1bccf42a75","children":[{"parent":"357028b6cd98","children":[],"id":"0663405d215e","title":"appendOnly"},{"parent":"357028b6cd98","children":[],"id":"9f6ab64116a9","title":"数据齐全"},{"parent":"357028b6cd98","children":[],"id":"c02dea9f0779","title":"回复慢文件大"}],"id":"357028b6cd98","title":"AOF"},{"parent":"0a1bccf42a75","children":[{"parent":"69f806ddca80","children":[],"id":"aff2f7029f87","title":"从节点发送命令主节点做bgsave同时开启buffer"}],"id":"69f806ddca80","title":"数据初始化"}],"id":"0a1bccf42a75","title":"持久化"},{"parent":"834989c97449","children":[{"parent":"d16de9b79faf","children":[{"parent":"5121fc79bd31","children":[{"parent":"c200141cef5a","children":[],"id":"0f2ddd2fbd82","title":"offset"}],"id":"c200141cef5a","title":"指令流"}],"id":"5121fc79bd31","title":"主从同步"},{"parent":"d16de9b79faf","children":[{"parent":"13a3b3f355a1","children":[{"parent":"d3da8208872a","children":[],"id":"e6067469418a","title":"缓冲区"}],"id":"d3da8208872a","title":"RDB"}],"id":"13a3b3f355a1","title":"快照同步"}],"id":"d16de9b79faf","title":"数据同步机制"},{"parent":"834989c97449","children":[{"parent":"ff51fab7d2be","children":[],"id":"ca33242df057","title":"集群监控"},{"parent":"ff51fab7d2be","children":[],"id":"08d50eed34e7","title":"消息通知"},{"parent":"ff51fab7d2be","children":[],"id":"52bbd545345b","title":"故障转移"},{"parent":"ff51fab7d2be","children":[],"id":"c996f8282e00","title":"配置中心"},{"parent":"ff51fab7d2be","children":[],"id":"b0415cd317d3","title":"脑裂"}],"id":"ff51fab7d2be","title":"哨兵"},{"parent":"834989c97449","children":[{"parent":"1809e77f09e2","children":[],"id":"5c71ce1e29c5","title":"链表"},{"parent":"1809e77f09e2","children":[{"parent":"63f20caa2b94","children":[],"id":"03f21dbad378","title":"横向扩容"}],"id":"63f20caa2b94","title":"多主"},{"parent":"1809e77f09e2","children":[],"id":"9b74bcca3d01","title":"分片"}],"id":"1809e77f09e2","title":"集群"}],"id":"834989c97449","title":"高可用"},{"parent":"c6ed55dfc9e7","children":[{"parent":"866bcf1d71a3","children":[{"parent":"a4ef42476f09","children":[],"id":"ca86bf848a41","title":"加随机值"},{"parent":"a4ef42476f09","children":[],"id":"5ad978c2bf21","title":"集群部署"}],"id":"a4ef42476f09","title":"缓存雪崩"},{"parent":"866bcf1d71a3","children":[{"parent":"15f74198c296","children":[],"id":"a52548e6d654","title":"互斥锁"},{"parent":"15f74198c296","children":[],"id":"ad3d1322921e","title":"热点数据不失效"}],"id":"15f74198c296","title":"缓存击穿"},{"parent":"866bcf1d71a3","children":[{"parent":"006482999d81","children":[],"id":"722a7df65c52","title":"布隆过滤器"}],"id":"006482999d81","title":"缓存穿透"},{"parent":"866bcf1d71a3","children":[{"parent":"2ab087b45ddd","children":[],"id":"f4afa6e6d3bd","title":"延时双删"}],"id":"2ab087b45ddd","title":"双写一致性"},{"parent":"866bcf1d71a3","children":[{"parent":"c0dfe1fc6784","children":[],"id":"0d19694c252f","title":"分布式锁"}],"id":"c0dfe1fc6784","title":"并发竞争"},{"parent":"866bcf1d71a3","children":[{"parent":"f4257816109c","children":[],"id":"6c34bb65663e","title":"bigkey命令 找到干掉"},{"parent":"f4257816109c","children":[],"id":"21b10ccd59a9","title":"Redis 4.0引入了memory usage命令和lazyfree机制"}],"id":"f4257816109c","title":"大Key"},{"parent":"866bcf1d71a3","children":[{"parent":"ed82880bacc1","children":[],"id":"0a4fe2432b67","title":"缓存时间不失效"},{"parent":"ed82880bacc1","children":[],"id":"9319ee9e8246","title":"多级缓存"},{"parent":"ed82880bacc1","children":[],"id":"47d8574d05ec","title":"布隆过滤器"},{"parent":"ed82880bacc1","children":[],"id":"27ff11a86460","title":"读写分离"}],"id":"ed82880bacc1","title":"热点key"}],"id":"866bcf1d71a3","title":"常见问题"},{"parent":"c6ed55dfc9e7","children":[{"parent":"a00236b12be2","children":[{"parent":"a9de7257bd50","children":[{"parent":"cb4c99833f06","children":[],"id":"f8a9acb7e497","title":"创建一个定时器"}],"id":"cb4c99833f06","title":"消耗内存"}],"id":"a9de7257bd50","title":"定时删除"},{"parent":"a00236b12be2","children":[{"parent":"628484b75f3d","children":[],"id":"d030ac1fd952","title":"可能存在大量key"}],"id":"628484b75f3d","title":"惰性删除"},{"parent":"a00236b12be2","children":[{"parent":"41eba060e246","children":[],"id":"4f7e92b0e17a","title":"检查 删除 但是是随机的"}],"id":"41eba060e246","title":"定期删除"}],"id":"a00236b12be2","title":"过期策略"},{"parent":"c6ed55dfc9e7","children":[{"parent":"924d10c2a660","children":[{"parent":"5d300e44cfff","children":[],"id":"a02eee98b785","title":"最少使用"}],"id":"5d300e44cfff","title":"LUR"}],"id":"924d10c2a660","title":"淘汰机制"},{"parent":"c6ed55dfc9e7","children":[{"parent":"3e29f300a2b1","children":[],"id":"536d89347956","title":"主从+哨兵+cluster"},{"parent":"3e29f300a2b1","children":[],"id":"e7200cd2023b","title":"ecache+Hystrix+降级+熔断+隔离"},{"parent":"3e29f300a2b1","children":[],"id":"106bb49e2317","title":"持久化"}],"id":"3e29f300a2b1","title":"备用方案"},{"parent":"c6ed55dfc9e7","children":[{"parent":"9c50e05c38ef","children":[],"id":"803a45d443f5","title":"setnx ex"},{"parent":"9c50e05c38ef","children":[{"parent":"a59bfefa9e2f","children":[],"id":"90134986e894","title":"窗口滑动"},{"parent":"a59bfefa9e2f","children":[],"id":"43947133c730","title":"zset会越来越大"}],"id":"a59bfefa9e2f","title":"zset"},{"parent":"9c50e05c38ef","children":[{"parent":"706f384d5e8d","children":[],"id":"71c4b0d4c498","title":"定时push"},{"parent":"706f384d5e8d","children":[],"id":"f26056544669","title":"然后leftpop"},{"parent":"706f384d5e8d","children":[{"parent":"ce621b388a38","children":[{"parent":"6e689750997f","children":[{"parent":"7f02520b416a","children":[{"parent":"e869e5527e77","children":[],"id":"31077703eace","title":"重试"}],"id":"e869e5527e77","title":"空连接异常"}],"id":"7f02520b416a","title":"blpop"}],"id":"6e689750997f","title":"空轮训"}],"id":"ce621b388a38","title":"问题"}],"id":"706f384d5e8d","title":"令牌"},{"parent":"9c50e05c38ef","children":[{"parent":"c02c577197ff","children":[{"parent":"de1e4abc51d2","children":[{"parent":"38652744f961","children":[{"parent":"2b5251a4ce40","children":[],"id":"462e78e5611f","title":"Redis-Cell"}],"id":"2b5251a4ce40","title":"原子性有问题"}],"id":"38652744f961","title":"Hash"}],"id":"de1e4abc51d2","title":"make_space 灌水之前调用漏水 腾出空间 取决于流水速率"}],"id":"c02c577197ff","title":"漏桶 funnel"},{"parent":"9c50e05c38ef","children":[],"id":"00ce86fe5a7c","title":"redis cell"}],"id":"9c50e05c38ef","title":"限流"},{"parent":"c6ed55dfc9e7","children":[{"parent":"719b1cd0a53d","children":[{"parent":"da79c777d157","children":[],"id":"0c43608cc870","title":"二级缓存"},{"parent":"da79c777d157","children":[],"id":"3ee9ce243949","title":"备份热key 走不同的机器"}],"id":"da79c777d157","title":"热点key"}],"id":"719b1cd0a53d","title":"选择方案"},{"parent":"c6ed55dfc9e7","children":[{"parent":"585995e30bab","children":[],"id":"372a6d94b183","title":"跳跃表"},{"parent":"585995e30bab","children":[],"id":"b6a1f87e0683","title":"令牌"},{"parent":"585995e30bab","children":[],"id":"695b6b05f94e","title":"漏桶"},{"parent":"585995e30bab","children":[],"id":"e1e5d906de08","title":"scan"}],"id":"585995e30bab","title":"扩展"},{"parent":"c6ed55dfc9e7","children":[{"parent":"12d388387425","children":[],"id":"1f945e5e5e9c","title":"&nbsp;read得读到很多才返回 为0会卡在那 直到新数据来或者链接关闭"},{"parent":"12d388387425","children":[],"id":"2e1a8771f639","title":"写不会阻塞除非缓冲区满了"},{"parent":"12d388387425","children":[],"id":"4c37ecb34428","title":"非阻塞的IO 提供了一个选项 no_blocking 读写都不会阻塞&nbsp; 读多少写多少 取决于内核的套接字字节分配"},{"parent":"12d388387425","children":[],"id":"96d140f0446a","title":"非阻塞IO也有问题 线程要读数据 读了一点就返回了 线程什么时候知道继续读？写一样"},{"parent":"12d388387425","children":[],"id":"7a2c82e8cdda","title":"一般都是select解决 但是性能低 现在都是epoll"}],"id":"12d388387425","title":"多路IO复用"}],"collapsed":false,"id":"c6ed55dfc9e7","title":"Redis"},{"parent":"root","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"parent":"516b18b924de","children":[{"parent":"7cc819b9444a","children":[],"id":"6a4235207457","title":"唯一主键"}],"id":"7cc819b9444a","title":"分库分表"},{"parent":"516b18b924de","children":[{"parent":"e21bf3f29b63","children":[{"parent":"550035ebd6d6","children":[],"id":"ebe69221a44a","title":"没视图概念 都是返回最新的"}],"id":"550035ebd6d6","title":"读未提交"},{"parent":"e21bf3f29b63","children":[{"parent":"96a0537d7565","children":[],"id":"7b493fca2926","title":"不同的read view"}],"id":"96a0537d7565","title":"读已提交"},{"parent":"e21bf3f29b63","children":[{"parent":"2000e5532d3b","children":[],"id":"0595e71c04ff","title":"用一个read view"}],"id":"2000e5532d3b","title":"可重复度"},{"parent":"e21bf3f29b63","children":[],"id":"e44af53e20bc","title":"序列化"},{"parent":"e21bf3f29b63","children":[{"parent":"3bfdf5682f64","children":[{"parent":"57635f3d7ed3","children":[],"id":"ff38d625f620","title":"5.5之前回滚段删了文件也不会变小"}],"id":"57635f3d7ed3","title":"没更早的read view删除"}],"id":"3bfdf5682f64","title":"回滚日志"}],"id":"e21bf3f29b63","title":"事务隔离级别"},{"parent":"516b18b924de","children":[{"parent":"cb3314e9a115","children":[],"id":"adc1fa2919af","title":"B+"},{"parent":"cb3314e9a115","children":[{"parent":"a89c74b26114","children":[],"id":"da009c95159d","title":"等值查询"}],"id":"a89c74b26114","title":"Hash"},{"parent":"cb3314e9a115","children":[{"parent":"b06d3205ef56","children":[],"id":"d4175e74b5db","title":"预发跑sql&nbsp; explain"},{"parent":"b06d3205ef56","children":[],"id":"39d37207ca93","title":"排除 缓存 sql nocache"},{"parent":"b06d3205ef56","children":[],"id":"0fe2de295bdc","title":"看一下行数对不对 不对可以用analyze table t 矫正"},{"parent":"b06d3205ef56","children":[],"id":"1321b7da80b9","title":"添加索引 索引不一定是最优的&nbsp; force index 强制走索引 不建议用"},{"parent":"b06d3205ef56","children":[],"id":"997a789a5304","title":"存在回表的情况"},{"parent":"b06d3205ef56","children":[{"parent":"953fa0f5ba2c","children":[],"id":"395dfd4d2f6c","title":"主键索引"}],"id":"953fa0f5ba2c","title":"覆盖索引避免回表，不要*"},{"parent":"b06d3205ef56","children":[],"id":"5f49acbe8067","title":"联合索引 不能无限建 高频场景"},{"parent":"b06d3205ef56","children":[],"id":"d23bb02c0df4","title":"最左前缀原则 按照索引定义的字段顺序写sql"},{"parent":"b06d3205ef56","children":[],"id":"0194be5a948a","title":"合理安排联合索引的顺序"},{"parent":"b06d3205ef56","children":[],"id":"dcfe90be268c","title":"5.6之后 索引下推 减少回表次数"},{"parent":"b06d3205ef56","children":[{"parent":"51d23d438603","children":[],"id":"1858c3e38ff7","title":"前缀索引"},{"parent":"51d23d438603","children":[],"id":"de40630911aa","title":"倒序存储"},{"parent":"51d23d438603","children":[],"id":"62b791ba2af8","title":"Hash"}],"id":"51d23d438603","title":"给字符串加索引"},{"parent":"b06d3205ef56","children":[{"parent":"6c101019b621","children":[],"id":"7d492f3b0506","title":"redo log满了 修改checkpoint flush到磁盘"},{"parent":"6c101019b621","children":[{"parent":"3ceb87c055ed","children":[{"parent":"55e23b8c7ab1","children":[],"id":"e07c59cf3290","title":"要知道磁盘的io能力 设置innodb_io_capacity 设置为磁盘的IOPS fio测试"},{"parent":"55e23b8c7ab1","children":[],"id":"cc336410fcae","title":"innodb_io_capacity设置低了 会让innoDB错误估算系统能力 导致脏页累积"}],"id":"55e23b8c7ab1","title":"buffer pool"}],"id":"3ceb87c055ed","title":"系统内存不足淘汰数据页"},{"parent":"6c101019b621","children":[],"id":"b5621b6ac4ba","title":"系统空闲的时候 找间隙刷脏页"},{"parent":"6c101019b621","children":[],"id":"f2375fbcedbc","title":"MySQL正常关闭，会把内存脏页flush到磁盘"}],"id":"6c101019b621","title":"数据库的flush的时机"},{"parent":"b06d3205ef56","children":[{"parent":"fdf1d1a5be80","children":[],"id":"e295af1295d9","title":"脏页比例"},{"parent":"fdf1d1a5be80","children":[],"id":"e264d48671ea","title":"redolog 写盘速度"},{"parent":"fdf1d1a5be80","children":[{"parent":"30d101c82741","children":[],"id":"ea38aeeefe3f","title":"机械磁盘的随机io不太行 减少随机io性能大幅提升 设置为 1最好"},{"parent":"30d101c82741","children":[],"id":"0d3f48e6c7f0","title":"现在都是ssd了 设置为0就够了 8.0之后默认是0"}],"id":"30d101c82741","title":"innodb_flush_neighbors 0&nbsp;"}],"id":"fdf1d1a5be80","title":"innodb刷盘速度"},{"parent":"b06d3205ef56","children":[{"parent":"bb57e0d8d60e","children":[],"id":"b29a11578978","title":"如果触发隐式转换 那也会走cast函数 会放弃走索引"}],"id":"bb57e0d8d60e","title":"索引字段不要做函数操作，会破坏索引值的有序性，优化器会放弃走树结构"},{"parent":"b06d3205ef56","children":[{"parent":"d021bec92159","children":[],"id":"286fa38eeb7b","title":"convert 也是函数所以走不上"}],"id":"d021bec92159","title":"字符集不同可能走不上索引"}],"id":"b06d3205ef56","title":"优化流程"},{"parent":"cb3314e9a115","children":[],"id":"f4844d35d51b","title":"聚集索引"},{"parent":"cb3314e9a115","children":[{"parent":"cd586cd04c86","children":[{"parent":"51ea83bbb430","children":[],"id":"b0f6b9363732","title":"减少回表"}],"id":"51ea83bbb430","title":"多扫描一次"}],"id":"cd586cd04c86","title":"非聚集索引"},{"parent":"cb3314e9a115","children":[{"parent":"2a174588e2f5","children":[],"id":"e6182f6ca422","title":"页满了 页分裂 页利用率下降"},{"parent":"2a174588e2f5","children":[],"id":"c79259078cde","title":"数据删除 页合并&nbsp;"},{"parent":"2a174588e2f5","children":[],"id":"df3b4978b6f5","title":"自增 只追加可以不考虑 也分页"},{"parent":"2a174588e2f5","children":[],"id":"51b6d4f380b2","title":"索引长度"}],"id":"2a174588e2f5","title":"索引维护"},{"parent":"cb3314e9a115","children":[{"parent":"a8e5656fed2d","children":[{"parent":"7cf03299ee37","children":[],"id":"a0990c3272c1","title":"找到第一个之后 直到朋友不满足的"}],"id":"7cf03299ee37","title":"普通索引"},{"parent":"a8e5656fed2d","children":[{"parent":"c24bc7dfaaff","children":[],"id":"772a680d714b","title":"找到第一个不满足的就停止了"}],"id":"c24bc7dfaaff","title":"唯一索引"},{"parent":"a8e5656fed2d","children":[{"parent":"aa3f5ee83e39","children":[],"id":"3a9671b9534d","title":"包含主键索引值"}],"collapsed":false,"id":"aa3f5ee83e39","title":"覆盖索引"},{"parent":"a8e5656fed2d","children":[{"parent":"cd1c84cd8c5c","children":[],"id":"96548b746410","title":"安排字段顺序"}],"id":"cd1c84cd8c5c","title":"最左前缀原则"},{"parent":"a8e5656fed2d","children":[{"parent":"d8cd0cfbbf16","children":[],"id":"793a51aa7b1b","title":"hash"}],"id":"d8cd0cfbbf16","title":"索引空间问题"},{"parent":"a8e5656fed2d","children":[{"parent":"28f747327fd2","children":[],"id":"489ef0e1c90f","title":"不需要多个回表&nbsp; 一边遍历 一边判断"}],"id":"28f747327fd2","title":"5.6之后索引下推"},{"parent":"a8e5656fed2d","children":[],"id":"608b798f5d84","title":"页的概念"},{"parent":"a8e5656fed2d","children":[{"parent":"0d60483d7dbb","children":[],"id":"0da90f9886fb","title":"change buffer"},{"parent":"0d60483d7dbb","children":[],"id":"0b967d466ae8","title":"更新操作来了 如果数据页不在内存 就缓存下来 下次来了 更新 在就直接更新"},{"parent":"0d60483d7dbb","children":[],"id":"3a4b2f580c3d","title":"唯一索引 需要判断 所以 用不到change buffer"},{"parent":"0d60483d7dbb","children":[{"parent":"75dfc6181a13","children":[{"parent":"1e7cb58becc1","children":[],"id":"04cb082a9363","title":"唯一索引 判断没冲突插入"},{"parent":"1e7cb58becc1","children":[],"id":"5fc37d28985b","title":"普通索引 插入"}],"id":"1e7cb58becc1","title":"记录在页内存"},{"parent":"75dfc6181a13","children":[{"parent":"b9d08701dd9b","children":[],"id":"21ad247dd59f","title":"数据页读入内存 判断 插入"},{"parent":"b9d08701dd9b","children":[],"id":"c128e59668f0","title":"change buffer"}],"id":"b9d08701dd9b","title":"记录不再页中"},{"parent":"75dfc6181a13","children":[],"id":"67653797d8df","title":"数据读是随机IO 成本高&nbsp;"},{"parent":"75dfc6181a13","children":[],"id":"77282a731aee","title":"机械硬盘 change buffer 收益大 写多读少 marge"}],"id":"75dfc6181a13","title":"innodb的处理流程"}],"id":"0d60483d7dbb","title":"更新"}],"id":"a8e5656fed2d","title":"索引选择"}],"id":"cb3314e9a115","title":"索引"},{"parent":"516b18b924de","children":[{"parent":"2a5023669f58","children":[],"id":"4d423cc028a3","title":"版本链&nbsp; 在聚集索引中 有两个隐藏列 trx_id&nbsp; roll_pointer"},{"parent":"2a5023669f58","children":[{"parent":"7061165c8b4f","children":[],"id":"69185c6e0831","title":"直接读取最新版本"}],"id":"7061165c8b4f","title":"读未提交"},{"parent":"2a5023669f58","children":[{"parent":"55c3f0475253","children":[],"id":"c1d69e67f121","title":"加锁"}],"id":"55c3f0475253","title":"序列化"},{"parent":"2a5023669f58","children":[{"parent":"1ffd77165571","children":[{"parent":"cdf33257722d","children":[],"id":"28b0cd61bc69","title":"每次读取前生成一个"}],"id":"cdf33257722d","title":"读已提交"},{"parent":"1ffd77165571","children":[{"parent":"430d7232568a","children":[],"id":"87df2517882d","title":"第一次生成一个"}],"id":"430d7232568a","title":"可重复度"}],"id":"1ffd77165571","title":"Read View"}],"id":"2a5023669f58","title":"MVCC"},{"parent":"516b18b924de","children":[{"parent":"95abc1701c0e","children":[{"parent":"365b9e921a88","children":[],"id":"d1721a4938f4","title":"全库逻辑备份"}],"id":"365b9e921a88","title":"全局锁"},{"parent":"95abc1701c0e","children":[{"parent":"d71f9e482ce0","children":[],"id":"b3fc39e97fcc","title":"lock table read/write"},{"parent":"d71f9e482ce0","children":[{"parent":"ee36f5a359cf","children":[],"id":"5c18e0b8523c","title":"MySQL5.5引入 自动添加&nbsp;读锁不互斥  写锁互斥"},{"parent":"ee36f5a359cf","children":[{"parent":"a04fb938a9c1","children":[],"id":"0f3b9f194d1a","title":"MySQL的information_schema 库的 innodb_trx 表 找到对应长事务 kill掉"},{"parent":"a04fb938a9c1","children":[],"id":"969cdf65c41d","title":"alter table里面设定等待时间"}],"id":"a04fb938a9c1","title":"多个事务之前操作，如果查询的时候修改字段容易让线程池饱满"}],"id":"ee36f5a359cf","title":"MDL（metadata lock)"},{"parent":"d71f9e482ce0","children":[],"id":"e5be47097efb","title":"Myisam是不支持表锁的"}],"id":"d71f9e482ce0","title":"表锁"},{"parent":"95abc1701c0e","children":[{"parent":"a1635259e31b","children":[],"id":"0a79ca0b2420","title":"需要的时候才加上 并不是马上释放 等事务结束才释放 两阶段锁协议"},{"parent":"a1635259e31b","children":[{"parent":"211216c557dc","children":[{"parent":"9d74a9c4b51b","children":[{"parent":"da8d20b6b3f6","children":[],"id":"b994333dc92a","title":"默认是50s太久 但是如果设置太短会误判 一般采用死锁监测"}],"id":"da8d20b6b3f6","title":"innodb_lock_wait_timeout"}],"id":"9d74a9c4b51b","title":"超时时间"},{"parent":"211216c557dc","children":[{"parent":"cb1a2d22befe","children":[],"id":"70fa61d7a04f","title":"innodb_deadlock_detect = on"}],"id":"cb1a2d22befe","title":"死锁机制 事务回滚"}],"id":"211216c557dc","title":"死锁"},{"parent":"a1635259e31b","children":[{"parent":"63e32cc94d1b","children":[{"parent":"b9153cceaa35","children":[{"parent":"b85913a07e30","children":[],"id":"880730f94b3c","title":"关掉死锁会出现大量重试"}],"id":"b85913a07e30","title":"临时关闭"}],"id":"b9153cceaa35","title":"死锁消耗CPU"},{"parent":"63e32cc94d1b","children":[{"parent":"5202fe23497c","children":[],"id":"df7e9f3620b0","title":"更多的机器 开启比较少的线程 消耗就少了"}],"id":"5202fe23497c","title":"控制并发度"},{"parent":"63e32cc94d1b","children":[],"id":"f5facededc98","title":"分治"}],"id":"63e32cc94d1b","title":"热点行"}],"id":"a1635259e31b","title":"行锁"},{"parent":"95abc1701c0e","children":[],"id":"cadf32bc17b3","title":"间隙锁"},{"parent":"95abc1701c0e","children":[{"parent":"5f61df69dd31","children":[{"parent":"2531c3374086","children":[],"id":"f1554cd7f384","title":"lock in share mode"},{"parent":"2531c3374086","children":[],"id":"54f47d50e888","title":"for update"},{"parent":"2531c3374086","children":[],"id":"2aa30cb5377e","title":"行锁"}],"id":"2531c3374086","title":"读"},{"parent":"5f61df69dd31","children":[],"id":"abaab4dd62a4","title":"写"}],"id":"5f61df69dd31","title":"读写锁"},{"parent":"95abc1701c0e","children":[{"parent":"18899d56591c","children":[],"id":"0a75a3147b62","title":"Record lock: 对索引项加锁。<br>Gap lock:对索引项之间的‘间隙’,第一条记录前的间隙，或最后一条记录后的间隙 加锁<br>Next-Key:前两种的组合，对记录及前面的间隙加锁"}],"id":"18899d56591c","title":"innodb如何加锁"}],"id":"95abc1701c0e","title":"锁"},{"parent":"516b18b924de","children":[],"id":"92cce9da64da","title":"B+"},{"parent":"516b18b924de","children":[{"parent":"43d686b4c933","children":[{"parent":"bc833b9a61ed","children":[],"id":"d8706213983d","title":"回滚 mvcc"}],"id":"bc833b9a61ed","title":"undo log","summaries":[]},{"parent":"43d686b4c933","children":[{"parent":"6e6827fa1651","children":[{"parent":"e2a33874ded5","children":[],"id":"b99129f73753","title":"sync_binlog 可以优化日志写入时机"}],"id":"e2a33874ded5","title":"物理日志 内存操作记录"}],"id":"6e6827fa1651","title":"redo log"},{"parent":"43d686b4c933","children":[{"parent":"868203a67934","children":[],"id":"b9403117f516","title":"组提交机制，可以大幅度降低磁盘的IOPS消耗。"}],"id":"868203a67934","title":"binlog"},{"parent":"43d686b4c933","children":[],"id":"88752dd026c1","title":"两段式提交 redo 准备 binglog 提交"}],"id":"43d686b4c933","title":"log"},{"parent":"516b18b924de","children":[{"parent":"28058f1ccf54","children":[],"id":"59aa129ded8a","title":"mvcc影响"}],"id":"28058f1ccf54","title":"count1 *"},{"parent":"516b18b924de","children":[{"parent":"c6add69b3dea","children":[],"id":"641f983ab9d2","title":"强制走主"},{"parent":"c6add69b3dea","children":[],"id":"8cd5e7873fe0","title":"sleep"}],"id":"c6add69b3dea","title":"主备延迟"},{"parent":"516b18b924de","children":[{"parent":"ccfee28eb349","children":[],"id":"d45b677bd5a9","title":"驱动表"}],"id":"ccfee28eb349","title":"join"},{"parent":"516b18b924de","children":[{"parent":"2407d68d7ec6","children":[],"id":"6251c0090649","title":"bigint"},{"parent":"2407d68d7ec6","children":[],"id":"a338abfe0e79","title":"row_id 没设置主键的时候"},{"parent":"2407d68d7ec6","children":[],"id":"e68eccf53a8d","title":"thread_id"}],"id":"2407d68d7ec6","title":"id用完"},{"parent":"516b18b924de","children":[{"parent":"5a90dda142f4","children":[],"id":"e815f8b27efc","title":"设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。<br><br>将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时会丢binlog日志。<br><br>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据。"}],"id":"5a90dda142f4","title":"mysql io性能瓶颈"},{"parent":"516b18b924de","children":[{"parent":"dda5df991165","children":[{"parent":"c8943965cfc7","children":[],"id":"d2613a7d5f7e","title":"查看空闲忙碌链接"},{"parent":"c8943965cfc7","children":[{"parent":"7d8dc85b897a","children":[{"parent":"e0a425ae20d9","children":[],"id":"403fa4f5c734","title":"定时断开链接"},{"parent":"e0a425ae20d9","children":[],"id":"2e49ef5ff709","title":"mysql_reset_connection 恢复链接状态"}],"id":"e0a425ae20d9","title":"客户端空闲时间"}],"id":"7d8dc85b897a","title":"wait_timeout"}],"id":"c8943965cfc7","title":"show processlist"},{"parent":"dda5df991165","children":[{"parent":"5de5fed6da4f","children":[],"id":"9c87068fedb6","title":"redolog事务持久化"}],"id":"5de5fed6da4f","title":"innodb_flush_log_at_trx_commit"},{"parent":"dda5df991165","children":[{"parent":"4991d6c14e47","children":[],"id":"47621f033b89","title":"binlog事务持久化"}],"id":"4991d6c14e47","title":"sync_binlog"}],"id":"dda5df991165","title":"常见命令"},{"parent":"516b18b924de","children":[{"parent":"ecffcd4a5f40","children":[],"id":"762d5849e652","title":"数据库挂了&nbsp;&nbsp; show processlist&nbsp; 一千个查询在等待 有个超长sql kill&nbsp; 但是不会引起flush table&nbsp; 周末 优化脚本 analyze 会导致 MySQL 监测到对应的table 做了修改 必须flush close reopen&nbsp; 就不会释放表的占用了<br>"}],"id":"ecffcd4a5f40","title":"真实故障"}],"collapsed":false,"id":"516b18b924de","title":"MySQL"},{"parent":"root","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"f42aceb1e990","children":[],"id":"9b95e0b17de2","title":"选举机制","summaries":[]},{"parent":"f42aceb1e990","children":[],"id":"a607437e4be7","title":"过半机制"},{"parent":"f42aceb1e990","children":[],"id":"d25e85572345","title":"预提交&nbsp; ack 2pc","summaries":[]},{"parent":"f42aceb1e990","children":[],"id":"dc8f271edfd0","title":"ZAB协议？"},{"parent":"f42aceb1e990","children":[],"id":"4249660fad81","title":"zk节点宕机如何处理？"},{"parent":"f42aceb1e990","children":[],"id":"d83ad0384d52","title":"如何实现分布式一致性"}],"collapsed":false,"id":"f42aceb1e990","title":"Zookeeper"},{"parent":"root","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"parent":"f7698d50eb22","children":[{"parent":"f79e8d10c93d","children":[{"parent":"f853ff54447c","children":[],"id":"bc1badc6f993","title":"阻塞IO 读写都阻塞&nbsp;&nbsp;"},{"parent":"f853ff54447c","children":[],"id":"61afc97d0ffb","title":"问题 带宽 资源等"},{"parent":"f853ff54447c","children":[],"id":"1de26cfcffbe","title":"每个请求过来 开一个线程阻塞"}],"id":"f853ff54447c","title":"bio"},{"parent":"f79e8d10c93d","children":[{"parent":"5f90b00440ad","children":[],"id":"6f8721fa830c","title":"不阻塞来着不拒"},{"parent":"5f90b00440ad","children":[{"parent":"d02bcd6eb03d","children":[{"parent":"37632455a760","children":[{"parent":"6ce90eab7f16","children":[],"id":"6ca394b87d2d","title":"程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”"}],"id":"6ce90eab7f16","title":"便捷的通知机制"}],"id":"37632455a760","title":"IO多路复用"},{"parent":"d02bcd6eb03d","children":[{"parent":"067553c1878d","children":[],"id":"69c0e23c7640","title":"遍历&nbsp; 判断事件是否可达 然后继续"}],"id":"067553c1878d","title":"select"},{"parent":"d02bcd6eb03d","children":[{"parent":"6dabd68a433f","children":[],"id":"43a69f8fb256","title":"做了优化"}],"id":"6dabd68a433f","title":"poll"},{"parent":"d02bcd6eb03d","children":[{"parent":"52d7975cbc54","children":[],"id":"b1eb6a000de9","title":"有转态&nbsp; 会创建 文件描述符指向的表 监听增删改查"}],"id":"52d7975cbc54","title":"epoll"}],"id":"d02bcd6eb03d","title":"但是可能等待时间太久 响应延迟大了 太短了 会重试"},{"parent":"5f90b00440ad","children":[{"parent":"0c123fce90a7","children":[],"id":"a77279978712","title":"监听事件"}],"id":"0c123fce90a7","title":"通道&nbsp; buffer 多路复用"}],"id":"5f90b00440ad","title":"nio"},{"parent":"f79e8d10c93d","children":[],"id":"2109882647cb","title":"aio"},{"parent":"f79e8d10c93d","children":[],"id":"6e4bc8790bd5","title":"架构设计思路"},{"parent":"f79e8d10c93d","children":[{"parent":"870c23fdab1b","children":[],"id":"ca6e54d1da98","title":"初始化channel&nbsp;"},{"parent":"870c23fdab1b","children":[{"parent":"ab2d5f3acb3c","children":[],"id":"ade22a25db67","title":"任务队列"}],"id":"ab2d5f3acb3c","title":"注册 channel到selector"},{"parent":"870c23fdab1b","children":[],"id":"ca5c8c08d9e6","title":"轮训accept事件&nbsp; 处理这些简历 channel的链接"},{"parent":"870c23fdab1b","children":[],"id":"6afacd103433","title":"注册 channel到selector 接收方"},{"parent":"870c23fdab1b","children":[{"parent":"75078b137565","children":[],"id":"3c8e9ddada01","title":"任务队列"}],"id":"75078b137565","title":"轮训写 事件 开线程去处理"}],"id":"870c23fdab1b","title":"执行链路"},{"parent":"f79e8d10c93d","children":[{"parent":"19ecaedc3de9","children":[{"parent":"a29f93291c33","children":[],"id":"68ed2aee4ab0","title":"监听端口所有准备就绪的时间"}],"id":"a29f93291c33","title":"boss"},{"parent":"19ecaedc3de9","children":[{"parent":"ce8fc463bfd8","children":[],"id":"921973af3377","title":"监听准备工作"}],"id":"ce8fc463bfd8","title":"work"}],"id":"19ecaedc3de9","title":"线程组"}],"id":"f79e8d10c93d","title":"Netty"},{"parent":"f7698d50eb22","children":[],"id":"8b35824fec2f","title":"调用链路"},{"parent":"f7698d50eb22","children":[{"parent":"0fae08b354ec","children":[],"id":"bca3538266a0","title":"IOC 启动加载dubbo配置的标签"},{"parent":"0fae08b354ec","children":[],"id":"8710449823dd","title":"解析标签 ServiceBean 会生成一个Bean"},{"parent":"0fae08b354ec","children":[{"parent":"3696db4265ad","children":[{"parent":"e18d29fe40cb","children":[],"id":"2623a72643d1","title":"get provider"},{"parent":"e18d29fe40cb","children":[],"id":"c351ab2a39d1","title":"set provider"},{"parent":"e18d29fe40cb","children":[],"id":"caa572f7d891","title":"各种信息 保存在 ServiceBean"}],"id":"e18d29fe40cb","title":"afterpropertiesSet"}],"id":"3696db4265ad","title":"实现了 initializingBean"},{"parent":"0fae08b354ec","children":[{"parent":"a914210dbf1b","children":[{"parent":"c12f4269fa93","children":[],"id":"13fab9dad855","title":"是否暴露 不是延迟暴露"}],"id":"c12f4269fa93","title":"回调onapplicationEvent"}],"id":"a914210dbf1b","title":"IOC完成 还实现了一个 ApplicationListener监听器"},{"parent":"0fae08b354ec","children":[{"parent":"22b38bf8de3a","children":[{"parent":"08ff1fbefefb","children":[],"id":"db872f75b318","title":"检查"},{"parent":"08ff1fbefefb","children":[{"parent":"7643b30c204f","children":[],"id":"789ea8040c2a","title":"加载注册中心信息"},{"parent":"7643b30c204f","children":[{"parent":"979f6a723554","children":[{"parent":"9ca34219f9fc","children":[{"parent":"8fa08c03a291","children":[],"id":"cd59978f58a4","title":"根据spi来"},{"parent":"8fa08c03a291","children":[],"id":"ea79f0783efc","title":"本地暴露"},{"parent":"8fa08c03a291","children":[],"id":"0c4c407eccd8","title":"打开 服务器&nbsp; exchangeServer"},{"parent":"8fa08c03a291","children":[],"id":"e39818a8cfc0","title":"启动服务器netty 监听端口"},{"parent":"8fa08c03a291","children":[{"parent":"f64b920cfb2a","children":[{"parent":"d793ad475646","children":[],"id":"6696147641b6","title":"执行器"}],"id":"d793ad475646","title":"注册表"}],"id":"f64b920cfb2a","title":"注册中心 注册服务"},{"parent":"8fa08c03a291","children":[],"id":"b67c358716a0","title":"暴露 p 和 s&nbsp; 两个invoker的map保存了地址"}],"id":"8fa08c03a291","title":"暴露invoke"},{"parent":"9ca34219f9fc","children":[],"id":"9dede5d6c009","title":"spi"}],"id":"9ca34219f9fc","title":"代理工厂获取invoke 封装"}],"id":"979f6a723554","title":"循环协议 端口"}],"id":"7643b30c204f","title":"doexportURL 暴露URL"}],"id":"08ff1fbefefb","title":"信息校验 doexport"}],"id":"22b38bf8de3a","title":"暴露"}],"id":"0fae08b354ec","title":"服务暴露过程"},{"parent":"f7698d50eb22","children":[{"parent":"9719aec454ed","children":[{"parent":"700ac40b05bf","children":[],"id":"6ec1b3165b83","title":"init"}],"id":"700ac40b05bf","title":"factoryBean -&gt;getObject -&gt;get"},{"parent":"9719aec454ed","children":[{"parent":"7cd71761bccc","children":[],"id":"15aa10d52329","title":"创建代理对象 createProxy"}],"id":"7cd71761bccc","title":"信息检查"},{"parent":"9719aec454ed","children":[{"parent":"910664c9d82b","children":[],"id":"ebcaa8fe5bd6","title":"dubbo 执行远程引用"}],"id":"910664c9d82b","title":"远程引用 获取到zk&nbsp; 获取到信息&nbsp; 订阅"},{"parent":"9719aec454ed","children":[{"parent":"2f563dceebec","children":[{"parent":"9ef3a613a8c1","children":[],"id":"6d791f6b1c86","title":"注册到注册表进去"}],"id":"9ef3a613a8c1","title":"返回invoke"}],"id":"2f563dceebec","title":"创建 netty客户端"},{"parent":"9719aec454ed","children":[],"id":"b7e149e2c228","title":"成功"}],"id":"9719aec454ed","title":"服务引用"},{"parent":"f7698d50eb22","children":[{"parent":"8e041faadd6f","children":[{"parent":"b183e2e87363","children":[],"id":"ed8886e76261","title":"Java 没ioc aop"}],"id":"b183e2e87363","title":"java spi"},{"parent":"8e041faadd6f","children":[{"parent":"1b4264a0ab51","children":[],"id":"7390a9024810","title":"静态代理"}],"id":"1b4264a0ab51","title":"具体的spi kv形式"}],"id":"8e041faadd6f","title":"SPI"},{"parent":"f7698d50eb22","children":[{"parent":"e47105aedf28","children":[{"parent":"c3ede3e7dc8d","children":[],"id":"3c5361eb3f97","title":"直接切换"}],"id":"c3ede3e7dc8d","title":"failover"},{"parent":"e47105aedf28","children":[{"parent":"fe16e26e2d83","children":[],"id":"38d0b2339043","title":"快速失败"}],"id":"fe16e26e2d83","title":"failfast"},{"parent":"e47105aedf28","children":[],"id":"904cc40fca0b","title":"failsafe"},{"parent":"e47105aedf28","children":[],"id":"8ab240ddf228","title":"failback"},{"parent":"e47105aedf28","children":[],"id":"a81df9b72d0e","title":"forking cluster"},{"parent":"e47105aedf28","children":[],"id":"beac28038aff","title":"broadcast cluster"},{"parent":"e47105aedf28","children":[{"parent":"3ab0e9cdefe2","children":[],"id":"aa30bcf3533d","title":"失败回调"},{"parent":"3ab0e9cdefe2","children":[],"id":"39ecd5fdb1c8","title":"返回默认"}],"id":"3ab0e9cdefe2","title":"整合 hystrix"}],"id":"e47105aedf28","title":"容错机制"},{"parent":"f7698d50eb22","children":[{"parent":"1d4efcc01bdd","children":[],"id":"aff5844cdce2","title":"return null"},{"parent":"1d4efcc01bdd","children":[],"id":"7f393134a7f6","title":"失败返回空"}],"id":"1d4efcc01bdd","title":"降级"},{"parent":"f7698d50eb22","children":[{"parent":"b6fa6d0f1da8","children":[],"id":"18aafabd6db2","title":"随机 加权"},{"parent":"b6fa6d0f1da8","children":[],"id":"a4c1bc4c468e","title":"轮训"},{"parent":"b6fa6d0f1da8","children":[],"id":"8105b1833852","title":"最少活跃数"},{"parent":"b6fa6d0f1da8","children":[],"id":"776354ad30fe","title":"hash一致"}],"id":"b6fa6d0f1da8","title":"负载均衡"},{"parent":"f7698d50eb22","children":[],"id":"94bfd9f58437","title":"选举算法"},{"parent":"f7698d50eb22","children":[],"id":"f52119c60ef2","title":"注册中心"},{"parent":"f7698d50eb22","children":[{"parent":"8e6c382552c6","children":[{"parent":"aabc7cd5164a","children":[],"id":"b1d18c6a4963","title":"默认 nio 单一长连接"},{"parent":"aabc7cd5164a","children":[],"id":"8948f45c850d","title":"二进制系列化&nbsp; 小数据量 100k"},{"parent":"aabc7cd5164a","children":[],"id":"826f052a5833","title":"数据量中等 不适合文件传输"}],"id":"aabc7cd5164a","title":"dubbo"},{"parent":"8e6c382552c6","children":[],"id":"68bcb64eea3f","title":"memcached"},{"parent":"8e6c382552c6","children":[],"id":"16c02d438e99","title":"redis"},{"parent":"8e6c382552c6","children":[],"id":"d6444e471821","title":"webService"},{"parent":"8e6c382552c6","children":[],"id":"5c26bfe05fc3","title":"http"}],"id":"8e6c382552c6","title":"协议"}],"collapsed":false,"id":"f7698d50eb22","title":"Dubbo"},{"parent":"root","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"parent":"feba7544f418","children":[{"parent":"e866406e3ccd","children":[{"parent":"ea32ed4a13c9","children":[],"id":"3918a6095701","title":"无状态模式"},{"parent":"ea32ed4a13c9","children":[],"id":"f92add36ac63","title":"broker向发心跳顺便带上所有的Topic信息"},{"parent":"ea32ed4a13c9","children":[],"id":"779cf5f184d7","title":"早期是zk后来改了"}],"id":"ea32ed4a13c9","title":"NameServer"},{"parent":"e866406e3ccd","children":[{"parent":"bed22cd975bd","children":[],"id":"7a8877c3474b","title":"中转消息，消息持久化"},{"parent":"bed22cd975bd","children":[],"id":"cecaa1f5ed23","title":"底层通信基于Netty"}],"id":"bed22cd975bd","title":"Broker"},{"parent":"e866406e3ccd","children":[{"parent":"8bd66d517ccc","children":[],"id":"1a6f04f858fa","title":"同步"},{"parent":"8bd66d517ccc","children":[],"id":"cf2449136aa3","title":"异步"},{"parent":"8bd66d517ccc","children":[],"id":"02d7e368fbf7","title":"单向"}],"id":"8bd66d517ccc","title":"Producer"},{"parent":"e866406e3ccd","children":[{"parent":"48f24d5a7197","children":[],"id":"01e75462e3ca","title":"pull"},{"parent":"48f24d5a7197","children":[],"id":"17c8dcc6fcca","title":"push"}],"id":"48f24d5a7197","title":"Consumer"}],"id":"e866406e3ccd","title":"基础组成"},{"parent":"feba7544f418","children":[{"parent":"d4905eb8e516","children":[],"id":"b9810f3d7d8b","title":"多master"},{"parent":"d4905eb8e516","children":[],"id":"cd735c219b42","title":"多master多slave异步复制"},{"parent":"d4905eb8e516","children":[],"id":"aa27250c79f3","title":"多master多slave双写"}],"id":"d4905eb8e516","title":"支持集群模式"},{"parent":"feba7544f418","children":[{"parent":"b1772181cb53","children":[],"id":"fa27678f0daa","title":"发送成功后返回consume_success"},{"parent":"b1772181cb53","children":[],"id":"b32cb95b0cf1","title":"回溯消费"}],"id":"b1772181cb53","title":"消费保证"},{"parent":"feba7544f418","children":[{"parent":"b58f6a327f98","children":[{"parent":"2b5dc5dc5c7c","children":[],"id":"ef62f30616e3","title":"NameService 集群"},{"parent":"2b5dc5dc5c7c","children":[],"id":"0b614404f9e7","title":"Broker 主从 双主 双从"},{"parent":"2b5dc5dc5c7c","children":[],"id":"b278d71ff016","title":"Consumer 自动切换"},{"parent":"2b5dc5dc5c7c","children":[],"id":"f662c6f5bb74","title":"producer 链接两个Broker"}],"id":"2b5dc5dc5c7c","title":"集群"},{"parent":"b58f6a327f98","children":[{"parent":"69e67200c215","children":[],"id":"1fde3a2a8523","title":"同步 超时会返回错误"},{"parent":"69e67200c215","children":[],"id":"a787a422b896","title":"异步 不返回"}],"id":"69e67200c215","title":"刷盘"},{"parent":"b58f6a327f98","children":[{"parent":"6639aaaafdc9","children":[],"id":"d5b560c29457","title":"同步复制"},{"parent":"6639aaaafdc9","children":[],"id":"7bd9bd0431fe","title":"异步复制"}],"id":"6639aaaafdc9","title":"消息的主从复制"},{"parent":"b58f6a327f98","children":[],"id":"1e017a0b5cb6","title":"主从同步&nbsp; 异步刷盘"}],"id":"b58f6a327f98","title":"高可用"},{"parent":"feba7544f418","children":[{"parent":"27388de7470e","children":[{"parent":"33bc5a015731","children":[{"parent":"6a82bb8a0b65","children":[{"parent":"4ad044e966a8","children":[],"id":"d6afc272eaab","title":"消费者是多线程"}],"id":"4ad044e966a8","title":"顺序发送 顺序消费由 消费者保证"}],"id":"6a82bb8a0b65","title":"RocketMQ提供了MessageQueueSelector队列选择机制"}],"id":"33bc5a015731","title":"Hash取模"}],"id":"27388de7470e","title":"顺序消息"},{"parent":"feba7544f418","children":[{"parent":"19f35ad22e6c","children":[],"id":"c7dd3edbc2d9","title":"幂等"},{"parent":"19f35ad22e6c","children":[{"parent":"c201ba5957de","children":[],"id":"5938f8a7ef68","title":"消息表主键冲突"}],"id":"c201ba5957de","title":"去重"}],"id":"19f35ad22e6c","title":"消息去重"},{"parent":"feba7544f418","children":[{"parent":"96747217ffed","children":[{"parent":"53406edda368","children":[],"id":"dc38a2a66cb2","title":"消息表 不断轮训 人工干预"}],"id":"53406edda368","title":"最大努力"},{"parent":"96747217ffed","children":[{"parent":"7ebdc3c2d4a6","children":[],"id":"b94c4b0cae6a","title":"发送半消息 发送成功 本地事务&nbsp; 觉得是否提交还是回滚 服务端没收到回查&nbsp; 检查本地事务 根据本地事务决定&nbsp; 提交"}],"id":"7ebdc3c2d4a6","title":"半消息"},{"parent":"96747217ffed","children":[],"id":"d3d58166256b","title":"2/3pc"},{"parent":"96747217ffed","children":[{"parent":"f436e28a4ad3","children":[],"id":"ab735a171c04","title":"预发 持久化&nbsp; 返回状态 发送处理结果&nbsp; 判断是否干掉持久化的&nbsp; 发送"}],"id":"f436e28a4ad3","title":"最终一致"}],"id":"96747217ffed","title":"分布式事务"},{"parent":"feba7544f418","children":[{"parent":"823e1f5aa2ed","children":[],"id":"1c42dacb9d86","title":"producer 和NameService 节点建立一个长连接"},{"parent":"823e1f5aa2ed","children":[],"id":"aa6070b128ad","title":"定期从NameService获取Topic信息&nbsp;"},{"parent":"823e1f5aa2ed","children":[],"id":"ce13a6974870","title":"并且向Broker Master 建立链接 发送心跳"},{"parent":"823e1f5aa2ed","children":[],"id":"883050aef0d3","title":"发送消息给 Broker Master"},{"parent":"823e1f5aa2ed","children":[],"id":"28fa48cc5833","title":"consumer 从 Mater 和 Slave 一起订阅消息"}],"id":"823e1f5aa2ed","title":"完整的一个调用链路"},{"parent":"feba7544f418","children":[{"parent":"3e06ac7cf0f2","children":[{"parent":"8cd4fdb90ded","children":[],"id":"bfb2991cd3fa","title":"不断重试 16次 4小时46分钟&nbsp; 可以修改尝试次数"},{"parent":"8cd4fdb90ded","children":[],"id":"c055826e2cc6","title":"对一个消费者设置&nbsp; 组内都会设置"},{"parent":"8cd4fdb90ded","children":[],"id":"6691a3d9a8ac","title":"可以获取消息重试次数"}],"id":"8cd4fdb90ded","title":"顺序消息重试"},{"parent":"3e06ac7cf0f2","children":[],"id":"79a76e72ceac","title":"无序消息重试"}],"id":"3e06ac7cf0f2","title":"消息重试"},{"parent":"feba7544f418","children":[{"parent":"7c6cbd05c102","children":[],"id":"4371bbaa8fc0","title":"不再被正常消费&nbsp;"},{"parent":"7c6cbd05c102","children":[],"id":"b15473135a2a","title":"保存3天"},{"parent":"7c6cbd05c102","children":[],"id":"380780c92333","title":"面向消费者组&nbsp;"},{"parent":"7c6cbd05c102","children":[],"id":"2e8bff8f6e90","title":"控制台 重发&nbsp; 重写消费者 单独消费"}],"id":"7c6cbd05c102","title":"死信队列"},{"parent":"feba7544f418","children":[],"id":"22281db9c7d4","title":"事务消息"},{"parent":"feba7544f418","children":[],"id":"c75c26abfb03","title":"消息丢失"},{"parent":"feba7544f418","children":[{"parent":"ffa0a0849729","children":[],"id":"8944bca14489","title":"决定是否丢弃"},{"parent":"ffa0a0849729","children":[],"id":"562732f30a16","title":"判断吞吐量&nbsp;"},{"parent":"ffa0a0849729","children":[],"id":"0a4d8932c047","title":"停止消费 加机器 加topic"}],"id":"ffa0a0849729","title":"消息积压"}],"collapsed":false,"id":"feba7544f418","title":"RocketMQ"},{"parent":"root","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"parent":"ad15522ae175","children":[{"parent":"cdd687c811f8","children":[],"id":"df9737d425e7","title":"死锁"},{"parent":"cdd687c811f8","children":[],"id":"ad14546d6d19","title":"羊群效应"},{"parent":"cdd687c811f8","children":[],"id":"97a71a41064a","title":"临时节点顺序"},{"parent":"cdd687c811f8","children":[],"id":"ab268c42daec","title":"性能没redis高"}],"id":"cdd687c811f8","title":"Zookeeper"},{"parent":"ad15522ae175","children":[{"parent":"91123590438b","children":[],"id":"53377da79bfd","title":"jedis.set(String key, String value, String nxxx, String expx, int time)"},{"parent":"91123590438b","children":[],"id":"3e0d47370e7e","title":"性能比较高"}],"id":"91123590438b","title":"Redis"},{"parent":"ad15522ae175","children":[{"parent":"030acba23717","children":[{"parent":"398b523cf44a","children":[],"id":"960f9993394b","title":"设置一个失效时间用定时任务去跑"},{"parent":"398b523cf44a","children":[],"id":"ad796253816f","title":"数据库集群 主备同步"},{"parent":"398b523cf44a","children":[],"id":"c8debd701f8a","title":"搞个死循环排队"},{"parent":"398b523cf44a","children":[],"id":"037a4f5bb60c","title":"可重入设计一个字段累加"}],"id":"398b523cf44a","title":"死锁"},{"parent":"030acba23717","children":[{"parent":"c87ee1af1b96","children":[],"id":"d7e38cdded28","title":"用数据库自身的锁就可以了 行锁&nbsp; 索引"},{"parent":"c87ee1af1b96","children":[],"id":"2b58c0b22c38","title":"select XX for update"},{"parent":"c87ee1af1b96","children":[],"id":"50c116d7e213","title":"记得 提交"},{"parent":"c87ee1af1b96","children":[],"id":"a9c5bd9c19a4","title":"宕机数据库也会自动释放锁"}],"id":"c87ee1af1b96","title":"排它锁"},{"parent":"030acba23717","children":[{"parent":"7df9851eeea0","children":[],"id":"f1ccddc03456","title":"比其他的更消耗资源&nbsp;"},{"parent":"7df9851eeea0","children":[],"id":"9ea27f071806","title":"复杂"}],"id":"7df9851eeea0","title":"缺点"}],"id":"030acba23717","title":"数据库"},{"parent":"ad15522ae175","children":[{"parent":"b8a45ecc7ca4","children":[],"id":"ea5d0b06d55c","title":"互斥"},{"parent":"b8a45ecc7ca4","children":[],"id":"3ab6e2718d5a","title":"安全性"},{"parent":"b8a45ecc7ca4","children":[],"id":"0bddb21c761c","title":"死锁"},{"parent":"b8a45ecc7ca4","children":[],"id":"9160c82569de","title":"容错"}],"id":"b8a45ecc7ca4","title":"特点"}],"collapsed":false,"id":"ad15522ae175","title":"分布式锁"},{"parent":"root","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"1c51613b1d39","children":[],"id":"be3f298a7ae6","title":"贪心"},{"parent":"1c51613b1d39","children":[],"id":"aa5790a65eeb","title":"分治"},{"parent":"1c51613b1d39","children":[],"id":"a83efccfacea","title":"动态规划"},{"parent":"1c51613b1d39","children":[],"id":"4f84b9ac2e5a","title":"快排"},{"parent":"1c51613b1d39","children":[],"id":"3d6d751ca554","title":"堆排"},{"parent":"1c51613b1d39","children":[],"id":"e2befae855fc","title":"二叉树"},{"parent":"1c51613b1d39","children":[],"id":"9684242b41fc","title":"链表反转"},{"parent":"1c51613b1d39","children":[],"id":"be4881d55b90","title":"成环"},{"parent":"1c51613b1d39","children":[],"id":"d1be92c7fecb","title":"环节点"},{"parent":"1c51613b1d39","children":[],"id":"cded6c9ce5fa","title":"跳楼梯"}],"collapsed":false,"id":"1c51613b1d39","title":"算法"},{"parent":"root","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"42a96ac984d3","children":[],"id":"a8a46b4a733d","title":"内存屏障"},{"parent":"42a96ac984d3","children":[],"id":"6c3119880b02","title":"指令乱序"},{"parent":"42a96ac984d3","children":[],"id":"3ef75ab1ddf0","title":"分支预测"},{"parent":"42a96ac984d3","children":[],"id":"2feaec15372d","title":"NUMA"},{"parent":"42a96ac984d3","children":[],"id":"5f0617140134","title":"CPU亲和性"}],"collapsed":false,"id":"42a96ac984d3","title":"扩展知识"},{"parent":"root","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"85a4014e932c","children":[{"parent":"6129553050d3","children":[{"parent":"0ade46ad871f","children":[{"parent":"01eb275affa3","children":[{"parent":"78753bb26ce7","children":[{"parent":"6958f65e4028","children":[],"id":"21f75a4da692","title":"然后就swap"}],"id":"6958f65e4028","title":"会重新加载整个RDB"}],"id":"78753bb26ce7","title":"这个时候做bgsave cow的机制就没了"}],"id":"01eb275affa3","title":"bgsave之后会做一个emptyDB"}],"id":"0ade46ad871f","title":"CPU彪升"}],"id":"6129553050d3","title":"sync遇到了bgsave"},{"parent":"85a4014e932c","children":[{"parent":"f3f684a40863","children":[{"parent":"d875c49a85a6","children":[{"parent":"4fe237723e60","children":[{"parent":"96f0ded30d5d","children":[],"id":"8454402f7230","title":"重连"}],"id":"96f0ded30d5d","title":"大量请求会让值升高 超出阈值断开"}],"id":"4fe237723e60","title":"master 复制缓存挤压区的时候 有个参数client-output-buffer-limit 默认1M"}],"id":"d875c49a85a6","title":"tps过高的时候"}],"id":"f3f684a40863","title":"高并发场景下无限同步"},{"parent":"85a4014e932c","children":[{"parent":"fc5d505c38f7","children":[{"parent":"336fcbd70c1c","children":[{"parent":"87d01976be78","children":[],"id":"576e97aa9241","title":"预估体量参数动态调整"}],"id":"87d01976be78","title":"slave重连对比offset发现空档重新sync"}],"id":"336fcbd70c1c","title":"阻塞久了复制缓冲区的数据就被冲掉了，是个队列会踢掉之前的数据"}],"id":"fc5d505c38f7","title":"slave做RDB同步的时候会导致TPS过高无法加载"},{"parent":"85a4014e932c","children":[],"id":"35ba03cd997f","title":"canal 并发修改"},{"parent":"85a4014e932c","children":[],"id":"d885f42b25e0","title":"es 自动机构建"},{"parent":"85a4014e932c","children":[],"id":"d8b1a8d81b2c","title":"redis es 深分页"},{"parent":"85a4014e932c","children":[],"id":"106fab408696","title":"实在没有可以去网上找找 但是得记熟悉"}],"collapsed":false,"id":"85a4014e932c","title":"遇到过的坑"},{"parent":"root","lineStyle":{"randomLineColor":"#FCB52A"},"children":[{"parent":"72c98c9e7fd7","children":[],"id":"6e47d39cb001","title":"我的回答有什么建议么"},{"parent":"72c98c9e7fd7","children":[],"id":"fcd135775e10","title":"阿里的解决方案"},{"parent":"72c98c9e7fd7","children":[],"id":"1f570a59039a","title":"团队主要做的事情"}],"collapsed":true,"id":"72c98c9e7fd7","title":"有什么想问我的"},{"parent":"root","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"parent":"0ab1d8c4e7f3","children":[{"parent":"e75bc6d331e9","children":[],"id":"821c7e566feb","title":"并发 多线程"},{"parent":"e75bc6d331e9","children":[],"id":"3b40f94c37bc","title":"业务亮点"},{"parent":"e75bc6d331e9","children":[{"parent":"223cdf620207","children":[],"id":"a875ee745259","title":"比如我自己之前做的一些中间件改造优化"},{"parent":"223cdf620207","children":[],"id":"79a76929707c","title":"大数据底层优化 融合改造"}],"id":"223cdf620207","title":"技术亮点"}],"id":"e75bc6d331e9","title":"一定要有核心亮点"},{"parent":"0ab1d8c4e7f3","children":[{"parent":"f1b3fd75e105","children":[],"id":"27a0d8ed53da","title":"可以是业务上的也可以技术上的"},{"parent":"f1b3fd75e105","children":[],"id":"e87ee8214ee1","title":"最好让对方看到你在团队视角的视野和格局，而不是局限于一个coder"}],"id":"f1b3fd75e105","title":"突出你在项目中做的事情和收获"},{"parent":"0ab1d8c4e7f3","children":[],"id":"95e15efabbec","title":"一定要对你简历上的每一个细节都了如指掌"}],"collapsed":false,"id":"0ab1d8c4e7f3","title":"项目"},{"parent":"root","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"parent":"8125030edf6b","children":[],"id":"82f2e88b36da","title":"全局报警"},{"parent":"8125030edf6b","children":[{"parent":"962acf507890","children":[],"id":"168daa60e606","title":"拦截spring事务"}],"id":"962acf507890","title":"分布式事务组件"}],"collapsed":false,"id":"8125030edf6b","title":"个人项目"},{"parent":"root","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"70a16626edb7","children":[],"id":"473112f270aa","title":"高并发下单"},{"parent":"70a16626edb7","children":[],"id":"7fddd1c731ca","title":"订单生成"}],"collapsed":false,"id":"70a16626edb7","title":"设计方案"},{"parent":"root","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"parent":"27acf6ec75ac","children":[{"parent":"e45dcdad399a","children":[],"id":"ef28c3050b56","title":"想去XX"},{"parent":"e45dcdad399a","children":[],"id":"0476407f3cf4","title":"成长受限"},{"parent":"e45dcdad399a","children":[],"id":"d64836674e57","title":"薪资"},{"parent":"e45dcdad399a","children":[],"id":"8b5a109b4285","title":"个人原因"},{"parent":"e45dcdad399a","children":[],"id":"ca70b4b092bb","title":"渴望大平台"}],"collapsed":true,"id":"e45dcdad399a","title":"为什么换工作"},{"parent":"27acf6ec75ac","children":[],"id":"555ce0d1788d","title":"职业规划"},{"parent":"27acf6ec75ac","children":[],"id":"ee0905d1e927","title":"之前的公司你怎么评价"},{"parent":"27acf6ec75ac","children":[],"id":"19e6fd0c6ff2","title":"有什么想问我的么？"}],"collapsed":false,"id":"27acf6ec75ac","title":"HR面"},{"parent":"root","lineStyle":{"randomLineColor":"#0F80C4"},"children":[],"pos":{"x":10456.77734375,"y":14173.834309895834},"id":"ca2166c1e208","title":"零拷贝","free":true}],"root":true,"theme":"delicate_caihong","id":"root","title":"三太子敖丙","version":3,"structure":"mind_right"}},"meta":{"exportTime":"2022-08-16 11:23:38","member":"61e4e79207912973ef28e73c","diagramInfo":{"creator":"61e4e79207912973ef28e73c","created":"2022-08-16 11:23:10","modified":"2022-08-16 11:23:10","title":"大厂java面试考点/学习路线","category":"mind_free"},"id":"62fb0d9e0791293111b256bb","type":"ProcessOn Schema File","version":"1.0"}}