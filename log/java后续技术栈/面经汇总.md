## 框架

### resource与aurowired的区别

参考：https://blog.csdn.net/weixin_40423597/article/details/80643990

功能：@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。

区别：

- @Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用。
- @Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。     
- 推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。



> @Autowired//默认按type注入
> @Qualifier("cusInfoService")//一般作为@Autowired()的修饰用
> @Resource(name="cusInfoService")//默认按name注入，可以通过name和type属性进行选择性注入

一般@Autowired和@Qualifier一起用，@Resource单独用。

当然没有冲突的话@Autowired也可以单独用

### 说说对MVC的理解

>MVC是一种设计模式,在这种模式下软件被分为了三层,M-model(模型层)、V-View(视图层)、C-Controlelr(控制层)
>
>1. 模型层主要是定义实体对象等数据
>2. 视图层主要是用户界面等
>3. 控制层主要是具体的业务逻辑相关负责请求的分发、把模型数据及时的反映在页面上
>4. 三层之间各司其职，降低了业务之间的耦合度。
>5. Spring MVC框架就是MVC设计模式的最好实现.

> MVC：本人理解为modal 、 view 、 controller； 当一个http请求过来之后，经过路由映射到controller，controller执行业务层代码，获得数据Modal，然后交给渲染器进行渲染视图view，最后返回给客户端一个modalAndView。 这个是SpringMvc的大致处理流程。 详细可以查看SpringMvc的工作原理。

### AOP和IOC

> AOP：全名面向切面编程，是一种编程思想。它是一种通过预编译方式和运行期间**动态代理**的方式实现不修改源代码的情况下给程序动态添加功能的一种技术（动态增强），可以降低代码的耦合度，便于管理。 将公共的、通用的、重复的功能或者业务逻辑提取出来，提高代码的可重用性。
>
> AOP的底层是使用动态代理实现，动态代理的实现方式有两种。
>
> AOP的实现方式有两种： JDK动态代理，可以在运行时创建接口的代理实例。 CGLIB动态代理：可以在运行期间创建子类的动态实例。
>
> AOP的应用场景有：事务的开启和提交、统一日志管理、统一异常处理等。



> IOC：全名控制反转，也是一种编程思想。**起初对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方**（也就是交给spring的IOC容器创建），获得依赖对象的方式反转了，从主动的创建变成了被动的获取。
>
> 而DI（依赖注入）是IOC的一种方法；
>
> 通俗来讲：其实就是有个盒子, 原来你是直接 new, 现在是把他扔盒子里, spring 去 new, 这个 new 的过程你看不见, spring 干了. 至于你什么时候想用从盒子里捞出来就行。

## Java基础

### 类初始化的流程

参考：https://blog.csdn.net/l1394049664/article/details/81235456

**类的初始化顺序**
（静态变量、静态初始化块：决于它们在类中出现的先后顺序）>（变量、初始化块：决于它们在类中出现的先后顺序）>构造器

原理：

1. 加载类信息。在实例化对象之前，类的装载器会找到需要加载的类class文件，进行类的加载（有父类的会先加载父类），一旦加载到最根上的基类，就会对基类的静态变量和静态初始化块进行初始化；
2. 当所有类信息加载完毕就会执行main（）主方法，然后执行new class（），对类进行实例化，首先对变量和、初始化块以及类的构造函数进行初始化（有父类的首先会对父类进行初始化，多个父类递归的方式）

**有父类的加载顺序**：
 父类--[静态变量](https://so.csdn.net/so/search?q=静态变量&spm=1001.2101.3001.7020)
 父类--静态初始化块
 子类--静态变量
 子类--静态初始化块
 子类main方法
 父类--变量
 父类--初始化块
 父类--构造器
 子类--变量
 子类--初始化块
 子类--构造器

**双亲委派机制**

1、双亲委派模型，约定类加载器的加载机制

![img](面经汇总/20180727131026862)

BootstrapClassLoader，由C++编写嵌套在JVM内部，负责加载“JAVA_HOME/lib”目录中的所有类型，或者由“-Xbootclasspath”指定路径中的所有类型。
ExtClassLoader和AppClassLoader都继承至ClassLoader抽象类，由Java编写；ExtClassLoader负责加载“JAVA_HOME/lib/ext”目录下的所有类型。
AppClassLoader负责加载ClassPath目录中的所有类型。
2、双亲委派模型的工作过程
双亲委派模型的工作过程是：如果**一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。**
3、使用这种方式的好处
能够有效确保一个类的全局唯一性，当程序中出现多个全限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。
4、实现双亲委派的代码java.lang.ClassLoader的loadClass()方法之中
逻辑清晰易懂：**先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载**。
5、双亲委派机制只是Java虚拟机规范建议采用的加载机制，在tomcat中扥实现有所不同
实际在tomcat中，类加载器所采用的加载机制与传统的双亲委派模型有一定的区别，当缺省的类加载器接收到一个类的加载任务时，首先会去由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行。
6、自定义类加载器
程序中如果没有显式指定类加载器的话，默认是AppClassLoader来加载，它负责加载ClassPath目录中的所有类型，如果被加载的类型并没有在ClassPath目录中时，抛出java.lang.ClassNotFoundException异常。
JDK1.2之后已不提倡用户再去覆盖loadClass()方法，而应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。

### Set是如何保证数据不重复的？

set的特点：

1. 元素无序
2. 元素不可重复

如何保证set的不可重复？

1. 在往set中添加对象时，首先会通过hashcode方法计算该对象的hash值
2. 将计算出来的hash值去hash表中查询，如果hash表中不存在此值，则添加成功。如果存在，那么将要进行进一步的比较，将已存在的对象与新添加对象进行比较，使用对象的e'quals方法来比较对象的field，如果field也相同，那么就是重复的对象，添加失败。如果equals返回的时false，则说明两个对象不相同，则将该对象添加到已有对象链表的末尾。这种情况叫做hash碰撞。



Set集合是通过hashCode和equals方法来保证元素不可重复的。之所以先计算hashCode，是为了提高添加的效率。所以当自定义对象需要保存到Set集合中的时候，就需要重写以上两个方法。

重写hashCode方法时的原则：
保证同一个对象返回的hash值相同。
不同对象计算出来的hash值不同。


## 数据库

### 1、innodb用的什么索引

b+，全文，不支持hash索引。

### 2、为什么索引不用二叉树而用b+树？

**二叉树查找树**：

由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（*假设一个节点的大小「小于」操作系统的最小读写单位块的大小*），也就是说**树的高度就等于每次查询数据时磁盘 IO 操作的次数**，所以树的高度越高，就会影响查询性能。

二叉查找树由于存在退化成链表的可能性

而且会随着插入的元素越多，树的高度也变高，意味着需要磁盘 IO 操作的次数就越多，这样导致查询性能严重下降，再加上不能范围查询，所以不适合作为数据库的索引结构。



数据库访问数据要通过页，一个页就是一个B+树节点，访问一个节点相当于一次I/O操作，所以越快能找到节点，查找性能越好。
B+树的特点就是够矮够胖，能有效地减少访问节点次数从而提高性能。



b树其实是一个平衡的多叉树。每个节点都有数据。

**B+树与B树的不同**：

1. B+树非叶子节点不存在数据只存索引，B树非叶子节点存储数据
2. **B+树查询效率更高**。B+树使用双向链表串连所有叶子节点，区间查询效率更高（因为所有数据都在B+树的叶子节点，扫描数据库 只需扫一遍叶子结点就行了），但是B树则需要通过中序遍历才能完成查询范围的查找。
3. B+树查询效率更稳定。B+树每次都必须查询到叶子节点才能找到数据，而B树查询的数据可能不在叶子节点，也可能在其他节点，这样就会造成查询的效率的不稳定
4. B+树的磁盘读写代价更小。B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，通常B+树矮更胖，高度小查询产生的I/O更少。



但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

- B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
- B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

### 3、项目中用到了redis，具体谈谈为什么？

**优点**

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 采用了非阻塞I/O多路复用机制
4. 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。
5. 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。

> **对于变动较少的数据，或者查询时间比较长的数据，我们可以将查询结果缓存到redis，这样请求就能够迅速响应，特别是秒杀系统，在这种高并发情况下，可以有效缓解数据库压力**
>
> 主从分离模式时代，在redis的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。

**常见问题**
1，redis缓存如何同数据库数据保持一致
2，缓存雪崩问题，
3，缓存击穿问题
4，缓存穿透问题
5，缓存的并发竞争问题
6，缓存预热
7，缓存更新
8，缓存降级

### 4、redis是线程安全的吗？并发环境下，redis跟mysql哪个好？如何去做选择？

- redis是线程安全的，因为只有一个线程，所以不存在线程安全的问题。

**MySQL和Redis的区别**：

1.mysql和redis的数据库类型mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。

redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。

2.mysql的运行机制mysql作为持久化存储的关系型数据库，相对薄弱的地方在于每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库。

第一：会在反复链接数据库上花费大量时间，从而导致运行效率过慢;

第二：反复的访问数据库也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来。

3.缓存缓存就是数据交换的缓冲区(cache)，当浏览器执行请求时，首先会对在缓存中进行查找，如果存在，就获取;否则就访问数据库。缓存的好处就是读取速度快!

4.redis数据库redis数据库就是一款缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率。

5.redis和mysql的**区别总结**

(1)类型上从类型上来说，mysql是关系型数据库，redis是缓存数据库

(2)作用上mysql用于持久化的存储数据到硬盘，功能强大，速度较慢，基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高redis用于存储使用较为频繁的数据到缓存中，读取速度快，基于内存，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，但内存价格贵

(3)**需求上mysql和redis因为需求的不同，一般都是配合使用。需要高性能的地方使用Redis，不需要高性能的地方使用MySQL。存储数据在MySQL和Redis之间做同步。**

**通俗讲redis和mysql的区别具体如下**：

1.mysql中一个中小型的网络数据库，比oracle和sqlserver小， 但是并发能力远超过acess这样的桌面数据库。

2.redis是一个支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。

3.可以认为redis比mysql简化很多。4.mysql支持集群。现在大量的软件使用redis作为mysql在本地的数据库缓存，然后再适当的时候和mysql同步.

### 5、说一下MySQL索引，以及他们的好处和坏处

**索引**

> 索引是一种帮助快速查找数据的数据结构，可以把索引理解为书的目录

**优点**

> 通过索引能够提高检索的效率

**缺点**

> 索引会增加存储压力，并且新增数据需要同步维护索引  

**详细**

> mysql使用不同的存储引擎使用不同的索引；
>
> 1. INNODB存储引擎可以建立聚簇索引(也称主键索引)，也可以建立非聚簇索引(二级索引)。
> 2. MYISAM存储引擎使用的是非聚簇索引，叶子节点存储的是地址的哈希值
> 3. 因而MYISAM适合进行等值查找，而不适合进行范围查询。
> 4. 不论是INNODB,还是MYISAM他们索引使用的数据结构是B+树，B+树有一个特点就是，非叶子节点存储的是目录项，而叶子节点存储的是数据项，因而可以通过二分查找快速定位到指定的数据项。
> 5. 在数据量比较大的前提下，适当的建立索引可以调高查询效率。
> 6. 但是索引如果建立太多也会导致查询效率低下，mysql在底层会进行判断，判断使用哪一种索引更加节省成本。
> 7. 索引还有一个缺点就是不易于进行维护，在进行数据的增删改操作后，会改变B+数的结构，会降低数据库的性能。

### 6、说说redis的数据类型

redis中常用的五种数据类型：string、list、set、zset、hash。

1. String结构底层是一个简单动态字符串，支持扩容，存储字符串。
2. list存储线性有序且可重复的元素，底层数据结构可以是双向链表/压缩列表。
3. set存储不可重复的元素，一般用于求交集、差集等，底层数据结构可以是hash和整数数组
4. zset存储的是有序不可重复的元素，zset为每个元素添加了一个score属性作为排序依据，底层数据结构可以是ziplist和跳表
5. hash类型存储的是键值对，底层数据结构是ziplist和hash。
6. redis会在性能以及节省内存间考虑，选择最适合当前状态的底层数据结构实现

### 7、乐观锁与悲观锁

> 乐观锁：总是假设最好的情况，就是再程序执行的过程中全程不上锁，只有在最后提交的时候才检查数据是否相等。可以使用版本号和CAS算法实现。



> 悲观锁：总是假设最坏的情况，每次拿数据的时候都认为被人会修改，所以在每次拿数据的时候都会上锁，这样被人在拿这个数据的时候就会阻塞，直到它拿到锁。

### 8、MySQL的null值会占用空间吗？



## 多线程

### 1、进程与线程的区别

**官方解释**：

1. 进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间；
2. 进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，消耗资源较大，效率要差一些。
3. 进程的并发性较低，线程的并发性较高
4. 每个独立的进程有一个程序的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制；
5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源；
6. 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程强壮。

**简洁语言**：

1.线程是进程的子集，一个进程中可以包含多个线程，每条线程执行不同的任务； 

2.不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间，减少切换次数，从而提高效率； 

3.每个线程拥有单独的栈内存用来存储本地数据。

4.同一个进程中的多个线程之间可以并发执行

5.一个程序至少有一个进程，一个进程至少有一个线程。

### 2、说说多线程

进程是操作系统资源调度的基本单位

线程是处理器任务调度和执行的基本单位

一个进程可以创建多个线程，每个线程有自己独立的程序计数器，本地方法栈和虚拟机栈，线程之间共享进程的堆和方法区。

线程之间是通过时间片算法来争夺CPU的执行权的。 

**多线程的好处**：当一个线程进入阻塞或者等待状态时，其他的线程可以获取CPU的执行权，提高了CPU的利用率。 

**多线程的缺点**：可能产生死锁；频繁的上下文切换可能会造成资源的浪费；在并发编程中如果因为资源的限制，多线程串行执行，可能速度会比单线程更慢。

### 3.、说说如何保证线程安全

多个线程同时操作共享资源时，就会出现线程安全问题。

这时就需要我们使用同步方案保证线程安全，常见的保证线程安全的方式有：

1. 原子类(底层使用CAS算法实现)
2. volatile关键字(1.可见性、2.防止指令重排、3.不保证原子性)
3. Lock类
4. 锁(JUC包下的lock锁)
5. synchronized关键字等保证线程安全
6. 使用ThreadLocal可以为每一个线程单独保存一份数据，避免了多线程访问共享变量。